"use strict";(self.webpackChunkmy_docs_site=self.webpackChunkmy_docs_site||[]).push([[643],{8453:(r,e,n)=>{n.d(e,{R:()=>s,x:()=>i});var t=n(6540);const o={},a=t.createContext(o);function s(r){const e=t.useContext(a);return t.useMemo((function(){return"function"==typeof r?r(e):{...e,...r}}),[e,r])}function i(r){let e;return e=r.disableParentContext?"function"==typeof r.components?r.components(o):r.components||o:s(r.components),t.createElement(a.Provider,{value:e},r.children)}},8516:(r,e,n)=>{n.r(e),n.d(e,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>s,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"advanced/error-handling","title":"Error Handling","description":"Learn how to properly handle errors and implement error recovery in Yukino.","source":"@site/docs/advanced/error-handling.md","sourceDirName":"advanced","slug":"/advanced/error-handling","permalink":"/docs/advanced/error-handling","draft":false,"unlisted":false,"editUrl":"https://github.com/yukino-org/yukino/tree/main/docs/docs/advanced/error-handling.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Voice State Management","permalink":"/docs/advanced/voice-state"},"next":{"title":"API Reference","permalink":"/docs/api/"}}');var o=n(4848),a=n(8453);const s={},i="Error Handling",c={},l=[{value:"Common Error Types",id:"common-error-types",level:2},{value:"Node Errors",id:"node-errors",level:3},{value:"Track Errors",id:"track-errors",level:3},{value:"Error Recovery System",id:"error-recovery-system",level:2},{value:"Error Logging",id:"error-logging",level:2},{value:"Best Practices",id:"best-practices",level:2}];function d(r){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,a.R)(),...r.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"error-handling",children:"Error Handling"})}),"\n",(0,o.jsx)(e.p,{children:"Learn how to properly handle errors and implement error recovery in Yukino."}),"\n",(0,o.jsx)(e.h2,{id:"common-error-types",children:"Common Error Types"}),"\n",(0,o.jsx)(e.h3,{id:"node-errors",children:"Node Errors"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"yukino.node.on('nodeError', (node, error) => {\r\n  console.error(`Node ${node.name} encountered an error:`, error);\r\n  // Implement recovery logic\r\n});\r\n\r\nyukino.node.on('nodeClosed', (node, code, reason) => {\r\n  console.error(`Node ${node.name} closed with code ${code}:`, reason);\r\n  // Handle unexpected disconnects\r\n});\n"})}),"\n",(0,o.jsx)(e.h3,{id:"track-errors",children:"Track Errors"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"yukino.node.on('trackError', (player, track, error) => {\r\n  console.error('Track playback failed:', {\r\n    track: track.info.title,\r\n    error: error.message\r\n  });\r\n  \r\n  // Skip to next track\r\n  player.skip().catch(console.error);\r\n});\r\n\r\nyukino.node.on('trackStuck', (player, track, thresholdMs) => {\r\n  console.warn('Track got stuck:', {\r\n    track: track.info.title,\r\n    threshold: thresholdMs\r\n  });\r\n  \r\n  // Skip or retry playback\r\n  player.seek(player.position + 1000).catch(() => player.skip());\r\n});\n"})}),"\n",(0,o.jsx)(e.h2,{id:"error-recovery-system",children:"Error Recovery System"}),"\n",(0,o.jsx)(e.p,{children:"Implement a robust error recovery system:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"class ErrorRecoverySystem {\r\n  private recoveryAttempts: Map<string, {\r\n    count: number;\r\n    lastError: Date;\r\n  }>;\r\n  \r\n  constructor(private yukino: YukinoClient) {\r\n    this.recoveryAttempts = new Map();\r\n    this.setupErrorHandlers();\r\n  }\r\n  \r\n  private setupErrorHandlers() {\r\n    // Node errors\r\n    this.yukino.node.on('nodeError', this.handleNodeError.bind(this));\r\n    this.yukino.node.on('nodeClosed', this.handleNodeClosed.bind(this));\r\n    \r\n    // Track errors\r\n    this.yukino.node.on('trackError', this.handleTrackError.bind(this));\r\n    this.yukino.node.on('trackStuck', this.handleTrackStuck.bind(this));\r\n    \r\n    // Voice errors\r\n    this.yukino.node.on('voiceStateUpdate', this.handleVoiceError.bind(this));\r\n  }\r\n  \r\n  private async handleNodeError(node: Node, error: Error) {\r\n    const attempts = this.getRecoveryAttempts(node.name);\r\n    \r\n    if (attempts.count < 3) {\r\n      // Try to reconnect\r\n      try {\r\n        await node.connect();\r\n        this.resetRecoveryAttempts(node.name);\r\n      } catch (e) {\r\n        attempts.count++;\r\n        attempts.lastError = new Date();\r\n        this.recoveryAttempts.set(node.name, attempts);\r\n      }\r\n    } else {\r\n      // Switch to fallback node if available\r\n      this.handleNodeFailover(node);\r\n    }\r\n  }\r\n  \r\n  private async handleNodeClosed(node: Node, code: number, reason: string) {\r\n    if (code === 1000) {\r\n      // Normal closure, no recovery needed\r\n      return;\r\n    }\r\n    \r\n    // Attempt reconnection with exponential backoff\r\n    const attempts = this.getRecoveryAttempts(node.name);\r\n    const backoff = Math.min(1000 * Math.pow(2, attempts.count), 30000);\r\n    \r\n    setTimeout(async () => {\r\n      try {\r\n        await node.connect();\r\n        this.resetRecoveryAttempts(node.name);\r\n      } catch (e) {\r\n        attempts.count++;\r\n        attempts.lastError = new Date();\r\n        this.recoveryAttempts.set(node.name, attempts);\r\n        \r\n        if (attempts.count < 5) {\r\n          this.handleNodeClosed(node, code, reason);\r\n        }\r\n      }\r\n    }, backoff);\r\n  }\r\n  \r\n  private async handleTrackError(player: Player, track: Track, error: Error) {\r\n    const attempts = this.getRecoveryAttempts(`track:${track.encoded}`);\r\n    \r\n    if (attempts.count < 2) {\r\n      // Try to restart the track\r\n      try {\r\n        await player.play({ track, options: { startTime: player.position } });\r\n        this.resetRecoveryAttempts(`track:${track.encoded}`);\r\n      } catch (e) {\r\n        attempts.count++;\r\n        attempts.lastError = new Date();\r\n        this.recoveryAttempts.set(`track:${track.encoded}`, attempts);\r\n        \r\n        // Skip to next track if restart fails\r\n        await player.skip().catch(console.error);\r\n      }\r\n    } else {\r\n      // Skip to next track after multiple failures\r\n      await player.skip().catch(console.error);\r\n    }\r\n  }\r\n  \r\n  private async handleTrackStuck(player: Player, track: Track, thresholdMs: number) {\r\n    // Try to seek past the stuck point\r\n    try {\r\n      await player.seek(player.position + thresholdMs);\r\n    } catch (e) {\r\n      // Skip if seeking fails\r\n      await player.skip().catch(console.error);\r\n    }\r\n  }\r\n  \r\n  private async handleVoiceError(state: any) {\r\n    const player = this.yukino.getPlayer(state.guild_id);\r\n    if (!player) return;\r\n    \r\n    const attempts = this.getRecoveryAttempts(`voice:${state.guild_id}`);\r\n    \r\n    if (attempts.count < 3) {\r\n      try {\r\n        await player.connect();\r\n        this.resetRecoveryAttempts(`voice:${state.guild_id}`);\r\n      } catch (e) {\r\n        attempts.count++;\r\n        attempts.lastError = new Date();\r\n        this.recoveryAttempts.set(`voice:${state.guild_id}`, attempts);\r\n      }\r\n    }\r\n  }\r\n  \r\n  private async handleNodeFailover(node: Node) {\r\n    // Find alternate node\r\n    const alternateNode = Array.from(this.yukino.connector.nodes.values())\r\n      .find(n => n !== node && n.state === State.CONNECTED);\r\n    \r\n    if (!alternateNode) {\r\n      console.error('No alternate nodes available');\r\n      return;\r\n    }\r\n    \r\n    // Move players to alternate node\r\n    for (const [guildId, player] of this.yukino.players) {\r\n      if (player.node === node) {\r\n        try {\r\n          const track = player.current;\r\n          const position = player.position;\r\n          \r\n          // Create new player on alternate node\r\n          const newPlayer = await this.yukino.createPlayer({\r\n            guildId: player.guildId,\r\n            voiceChannelId: player.voiceChannelId,\r\n            textChannelId: player.textChannelId\r\n          });\r\n          \r\n          // Restore playback state\r\n          if (track) {\r\n            await newPlayer.play({\r\n              track,\r\n              options: { startTime: position }\r\n            });\r\n          }\r\n          \r\n          // Copy queue\r\n          player.queue.tracks.forEach(t => newPlayer.queue.add(t));\r\n        } catch (e) {\r\n          console.error(`Failed to migrate player for guild ${guildId}:`, e);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  private getRecoveryAttempts(id: string) {\r\n    return (\r\n      this.recoveryAttempts.get(id) || {\r\n        count: 0,\r\n        lastError: new Date()\r\n      }\r\n    );\r\n  }\r\n  \r\n  private resetRecoveryAttempts(id: string) {\r\n    this.recoveryAttempts.set(id, {\r\n      count: 0,\r\n      lastError: new Date()\r\n    });\r\n  }\r\n  \r\n  // Cleanup\r\n  public destroy() {\r\n    this.recoveryAttempts.clear();\r\n  }\r\n}\n"})}),"\n",(0,o.jsx)(e.h2,{id:"error-logging",children:"Error Logging"}),"\n",(0,o.jsx)(e.p,{children:"Implement comprehensive error logging:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"class ErrorLogger {\r\n  constructor(\r\n    private yukino: YukinoClient,\r\n    private options: {\r\n      logToFile?: boolean;\r\n      logToConsole?: boolean;\r\n      logDirectory?: string;\r\n    } = {}\r\n  ) {\r\n    this.setupLoggers();\r\n  }\r\n  \r\n  private setupLoggers() {\r\n    // Node errors\r\n    this.yukino.node.on('nodeError', (node, error) => {\r\n      this.logError('NODE_ERROR', {\r\n        node: node.name,\r\n        error: error.message,\r\n        stack: error.stack\r\n      });\r\n    });\r\n    \r\n    // Track errors\r\n    this.yukino.node.on('trackError', (player, track, error) => {\r\n      this.logError('TRACK_ERROR', {\r\n        guild: player.guildId,\r\n        track: track.info.title,\r\n        error: error.message\r\n      });\r\n    });\r\n    \r\n    // Voice errors\r\n    this.yukino.node.on('voiceStateUpdate', (state) => {\r\n      if (state.error) {\r\n        this.logError('VOICE_ERROR', {\r\n          guild: state.guild_id,\r\n          error: state.error\r\n        });\r\n      }\r\n    });\r\n  }\r\n  \r\n  private logError(type: string, data: any) {\r\n    const timestamp = new Date().toISOString();\r\n    const logEntry = {\r\n      timestamp,\r\n      type,\r\n      ...data\r\n    };\r\n    \r\n    if (this.options.logToConsole) {\r\n      console.error(`[${timestamp}] ${type}:`, data);\r\n    }\r\n    \r\n    if (this.options.logToFile) {\r\n      // Implement file logging\r\n      const path = require('path');\r\n      const fs = require('fs');\r\n      const logPath = path.join(\r\n        this.options.logDirectory || 'logs',\r\n        `yukino-${new Date().toISOString().split('T')[0]}.log`\r\n      );\r\n      \r\n      fs.appendFileSync(\r\n        logPath,\r\n        JSON.stringify(logEntry) + '\\n'\r\n      );\r\n    }\r\n  }\r\n}\n"})}),"\n",(0,o.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Implement circuit breakers:"}),"\n"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"class CircuitBreaker {\r\n  private failures = 0;\r\n  private lastFailure: Date | null = null;\r\n  private state: 'closed' | 'open' | 'half-open' = 'closed';\r\n  \r\n  constructor(\r\n    private threshold: number = 5,\r\n    private timeout: number = 60000\r\n  ) {}\r\n  \r\n  async execute<T>(operation: () => Promise<T>): Promise<T> {\r\n    if (this.state === 'open') {\r\n      if (this.shouldReset()) {\r\n        this.state = 'half-open';\r\n      } else {\r\n        throw new Error('Circuit breaker is open');\r\n      }\r\n    }\r\n    \r\n    try {\r\n      const result = await operation();\r\n      if (this.state === 'half-open') {\r\n        this.reset();\r\n      }\r\n      return result;\r\n    } catch (error) {\r\n      this.recordFailure();\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  private recordFailure() {\r\n    this.failures++;\r\n    this.lastFailure = new Date();\r\n    \r\n    if (this.failures >= this.threshold) {\r\n      this.state = 'open';\r\n    }\r\n  }\r\n  \r\n  private shouldReset(): boolean {\r\n    return (\r\n      this.lastFailure &&\r\n      Date.now() - this.lastFailure.getTime() >= this.timeout\r\n    );\r\n  }\r\n  \r\n  private reset() {\r\n    this.failures = 0;\r\n    this.lastFailure = null;\r\n    this.state = 'closed';\r\n  }\r\n}\n"})}),"\n",(0,o.jsxs)(e.ol,{start:"2",children:["\n",(0,o.jsx)(e.li,{children:"Implement retry with exponential backoff:"}),"\n"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"async function withRetry<T>(\r\n  operation: () => Promise<T>,\r\n  maxAttempts = 3,\r\n  baseDelay = 1000\r\n): Promise<T> {\r\n  for (let attempt = 1; attempt <= maxAttempts; attempt++) {\r\n    try {\r\n      return await operation();\r\n    } catch (error) {\r\n      if (attempt === maxAttempts) throw error;\r\n      \r\n      const delay = baseDelay * Math.pow(2, attempt - 1);\r\n      await new Promise(r => setTimeout(r, delay));\r\n    }\r\n  }\r\n  \r\n  throw new Error('Should not reach here');\r\n}\n"})}),"\n",(0,o.jsxs)(e.ol,{start:"3",children:["\n",(0,o.jsx)(e.li,{children:"Handle cleanup properly:"}),"\n"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"process.on('SIGINT', async () => {\r\n  // Gracefully stop all players\r\n  for (const [_, player] of yukino.players) {\r\n    try {\r\n      await player.stop();\r\n      await player.disconnect();\r\n      await player.destroy();\r\n    } catch (error) {\r\n      console.error('Cleanup error:', error);\r\n    }\r\n  }\r\n  \r\n  // Disconnect from nodes\r\n  for (const [_, node] of yukino.connector.nodes) {\r\n    try {\r\n      await node.destroy();\r\n    } catch (error) {\r\n      console.error('Node cleanup error:', error);\r\n    }\r\n  }\r\n  \r\n  process.exit(0);\r\n});\n"})})]})}function p(r={}){const{wrapper:e}={...(0,a.R)(),...r.components};return e?(0,o.jsx)(e,{...r,children:(0,o.jsx)(d,{...r})}):d(r)}}}]);