"use strict";(self.webpackChunkmy_docs_site=self.webpackChunkmy_docs_site||[]).push([[846],{2926:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>p,frontMatter:()=>s,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"api/connectors","title":"Connectors","description":"Connectors handle the integration between Yukino and Discord client libraries. They manage voice state updates and server updates.","source":"@site/docs/api/connectors.md","sourceDirName":"api","slug":"/api/connectors","permalink":"/docs/api/connectors","draft":false,"unlisted":false,"editUrl":"https://github.com/yukino-org/yukino/tree/main/docs/docs/api/connectors.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"REST API","permalink":"/docs/api/rest"},"next":{"title":"Types Reference","permalink":"/docs/api/types"}}');var o=r(4848),i=r(8453);const s={},c="Connectors",a={},d=[{value:"Base Connector",id:"base-connector",level:2},{value:"Properties",id:"properties",level:3},{value:"Methods",id:"methods",level:3},{value:"<code>createNode(options: NodeOptions)</code>",id:"createnodeoptions-nodeoptions",level:4},{value:"<code>destroyNode(node: Node)</code>",id:"destroynodenode-node",level:4},{value:"<code>createPlayer(options: PlayerOptions)</code>",id:"createplayeroptions-playeroptions",level:4},{value:"<code>destroyPlayer(player: Player)</code>",id:"destroyplayerplayer-player",level:4},{value:"<code>loadTrack(query: string)</code>",id:"loadtrackquery-string",level:4},{value:"DiscordJSConnector",id:"discordjsconnector",level:2},{value:"Constructor",id:"constructor",level:3},{value:"Voice State Management",id:"voice-state-management",level:3},{value:"Voice Connection",id:"voice-connection",level:3},{value:"<code>sendVoiceUpdate(guildId: string, channelId: string | null, mute?: boolean, deaf?: boolean)</code>",id:"sendvoiceupdateguildid-string-channelid-string--null-mute-boolean-deaf-boolean",level:4},{value:"Creating Custom Connectors",id:"creating-custom-connectors",level:2},{value:"Required Implementations",id:"required-implementations",level:3},{value:"Example: Minimal Custom Connector",id:"example-minimal-custom-connector",level:3},{value:"Best Practices",id:"best-practices",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"connectors",children:"Connectors"})}),"\n",(0,o.jsx)(n.p,{children:"Connectors handle the integration between Yukino and Discord client libraries. They manage voice state updates and server updates."}),"\n",(0,o.jsx)(n.h2,{id:"base-connector",children:"Base Connector"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"Connector"})," class is the base class for platform-specific implementations."]}),"\n",(0,o.jsx)(n.h3,{id:"properties",children:"Properties"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"abstract class Connector extends EventEmitter {\r\n  public clientId: string;\r\n  public nodes: Map<string, Node>;\r\n  public voiceStates: Map<string, any>;\r\n  public voiceServers: Map<string, any>;\r\n  protected options: Required<ConnectorOptions>;\r\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"methods",children:"Methods"}),"\n",(0,o.jsx)(n.h4,{id:"createnodeoptions-nodeoptions",children:(0,o.jsx)(n.code,{children:"createNode(options: NodeOptions)"})}),"\n",(0,o.jsx)(n.p,{children:"Creates a new Lavalink node instance."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"const node = connector.createNode({\r\n  name: 'main',\r\n  url: 'localhost:2333',\r\n  auth: 'password'\r\n});\n"})}),"\n",(0,o.jsx)(n.h4,{id:"destroynodenode-node",children:(0,o.jsx)(n.code,{children:"destroyNode(node: Node)"})}),"\n",(0,o.jsx)(n.p,{children:"Destroys and removes a node instance."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"connector.destroyNode(node);\n"})}),"\n",(0,o.jsx)(n.h4,{id:"createplayeroptions-playeroptions",children:(0,o.jsx)(n.code,{children:"createPlayer(options: PlayerOptions)"})}),"\n",(0,o.jsx)(n.p,{children:"Creates a new player instance."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"const player = connector.createPlayer({\r\n  guildId: 'guild-id',\r\n  voiceChannelId: 'channel-id'\r\n});\n"})}),"\n",(0,o.jsx)(n.h4,{id:"destroyplayerplayer-player",children:(0,o.jsx)(n.code,{children:"destroyPlayer(player: Player)"})}),"\n",(0,o.jsx)(n.p,{children:"Destroys and cleans up a player instance."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"await connector.destroyPlayer(player);\n"})}),"\n",(0,o.jsx)(n.h4,{id:"loadtrackquery-string",children:(0,o.jsx)(n.code,{children:"loadTrack(query: string)"})}),"\n",(0,o.jsx)(n.p,{children:"Loads a track from a URL or search query."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"const result = await connector.loadTrack('search query');\n"})}),"\n",(0,o.jsx)(n.h2,{id:"discordjsconnector",children:"DiscordJSConnector"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"DiscordJSConnector"})," class implements the base ",(0,o.jsx)(n.code,{children:"Connector"})," for Discord.js."]}),"\n",(0,o.jsx)(n.h3,{id:"constructor",children:"Constructor"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"import { Client } from 'discord.js';\r\nimport { DiscordJSConnector } from 'yukino';\r\n\r\nconst connector = new DiscordJSConnector({\r\n  client: client,\r\n  auth: 'password',\r\n  debug: true\r\n});\n"})}),"\n",(0,o.jsx)(n.h3,{id:"voice-state-management",children:"Voice State Management"}),"\n",(0,o.jsx)(n.p,{children:"The connector automatically handles voice state and server updates from Discord:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"// These are handled internally\r\nclient.on('voiceStateUpdate', (oldState, newState) => {\r\n  connector.handleVoiceStateUpdate(newState);\r\n});\r\n\r\nclient.on('voiceServerUpdate', (data) => {\r\n  connector.handleVoiceServerUpdate(data);\r\n});\n"})}),"\n",(0,o.jsx)(n.h3,{id:"voice-connection",children:"Voice Connection"}),"\n",(0,o.jsx)(n.h4,{id:"sendvoiceupdateguildid-string-channelid-string--null-mute-boolean-deaf-boolean",children:(0,o.jsx)(n.code,{children:"sendVoiceUpdate(guildId: string, channelId: string | null, mute?: boolean, deaf?: boolean)"})}),"\n",(0,o.jsx)(n.p,{children:"Sends voice state updates to Discord."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"// Join a voice channel\r\nawait connector.sendVoiceUpdate('guild-id', 'channel-id', false, false);\r\n\r\n// Leave a voice channel\r\nawait connector.sendVoiceUpdate('guild-id', null);\n"})}),"\n",(0,o.jsx)(n.h2,{id:"creating-custom-connectors",children:"Creating Custom Connectors"}),"\n",(0,o.jsxs)(n.p,{children:["You can create custom connectors for other Discord library implementations by extending the base ",(0,o.jsx)(n.code,{children:"Connector"})," class:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"import { Connector } from 'yukino';\r\n\r\nclass CustomConnector extends Connector {\r\n  constructor(options: ConnectorOptions) {\r\n    super(options);\r\n    // Initialize your custom connector\r\n  }\r\n\r\n  public async sendVoiceUpdate(\r\n    guildId: string,\r\n    channelId: string | null,\r\n    mute?: boolean,\r\n    deaf?: boolean\r\n  ): Promise<void> {\r\n    // Implement voice state update logic for your library\r\n  }\r\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"required-implementations",children:"Required Implementations"}),"\n",(0,o.jsx)(n.p,{children:"Custom connectors must implement:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Voice state update handling"}),"\n",(0,o.jsx)(n.li,{children:"Voice server update handling"}),"\n",(0,o.jsx)(n.li,{children:"Client ID management"}),"\n",(0,o.jsx)(n.li,{children:"Voice channel connection/disconnection"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"example-minimal-custom-connector",children:"Example: Minimal Custom Connector"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"class MinimalConnector extends Connector {\r\n  private client: any; // Your client type\r\n\r\n  constructor(options: ConnectorOptions) {\r\n    super(options);\r\n    this.client = options.client;\r\n    \r\n    // Set up event listeners\r\n    this.client.on('voiceStateUpdate', this.onVoiceStateUpdate.bind(this));\r\n    this.client.on('voiceServerUpdate', this.onVoiceServerUpdate.bind(this));\r\n  }\r\n\r\n  private onVoiceStateUpdate(data: any): void {\r\n    this.voiceStates.set(data.guild_id, {\r\n      sessionId: data.session_id,\r\n      channelId: data.channel_id,\r\n      userId: data.user_id\r\n    });\r\n    \r\n    this.updateVoiceState(data.guild_id);\r\n  }\r\n\r\n  private onVoiceServerUpdate(data: any): void {\r\n    this.voiceServers.set(data.guild_id, {\r\n      token: data.token,\r\n      endpoint: data.endpoint\r\n    });\r\n    \r\n    this.updateVoiceState(data.guild_id);\r\n  }\r\n\r\n  private updateVoiceState(guildId: string): void {\r\n    const state = this.voiceStates.get(guildId);\r\n    const server = this.voiceServers.get(guildId);\r\n    \r\n    if (state && server) {\r\n      // Update the node with new voice state\r\n      const node = this.nodes.values().next().value;\r\n      if (node) {\r\n        node.updateVoiceState(guildId, state, server);\r\n      }\r\n    }\r\n  }\r\n\r\n  public async sendVoiceUpdate(\r\n    guildId: string,\r\n    channelId: string | null,\r\n    mute = false,\r\n    deaf = false\r\n  ): Promise<void> {\r\n    await this.client.updateVoiceState({\r\n      guild_id: guildId,\r\n      channel_id: channelId,\r\n      self_mute: mute,\r\n      self_deaf: deaf\r\n    });\r\n  }\r\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Handle voice state cleanup:"}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"class BetterConnector extends Connector {\r\n  public destroy(): void {\r\n    this.voiceStates.clear();\r\n    this.voiceServers.clear();\r\n    this.nodes.clear();\r\n  }\r\n}\n"})}),"\n",(0,o.jsxs)(n.ol,{start:"2",children:["\n",(0,o.jsx)(n.li,{children:"Implement error handling:"}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"class RobustConnector extends Connector {\r\n  public async sendVoiceUpdate(...args): Promise<void> {\r\n    try {\r\n      await super.sendVoiceUpdate(...args);\r\n    } catch (error) {\r\n      this.emit('error', error);\r\n      throw error;\r\n    }\r\n  }\r\n}\n"})}),"\n",(0,o.jsxs)(n.ol,{start:"3",children:["\n",(0,o.jsx)(n.li,{children:"Add debug logging:"}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"class DebugConnector extends Connector {\r\n  private logger: Logger;\r\n\r\n  constructor(options: ConnectorOptions) {\r\n    super(options);\r\n    this.logger = Logger.create('Connector', options.debug || false);\r\n  }\r\n\r\n  protected onVoiceStateUpdate(data: any): void {\r\n    this.logger.debug('Voice state update:', data);\r\n    super.onVoiceStateUpdate(data);\r\n  }\r\n}\n"})})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>c});var t=r(6540);const o={},i=t.createContext(o);function s(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);