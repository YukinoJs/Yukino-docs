"use strict";(self.webpackChunkmy_docs_site=self.webpackChunkmy_docs_site||[]).push([[464],{3035:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"advanced/voice-state","title":"Voice State Management","description":"Learn how to handle voice state updates and manage voice connections in Yukino.","source":"@site/docs/advanced/voice-state.md","sourceDirName":"advanced","slug":"/advanced/voice-state","permalink":"/docs/advanced/voice-state","draft":false,"unlisted":false,"editUrl":"https://github.com/yukino-org/yukino/tree/main/docs/docs/advanced/voice-state.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Custom Filters","permalink":"/docs/advanced/custom-filters"},"next":{"title":"Error Handling","permalink":"/docs/advanced/error-handling"}}');var a=r(4848),i=r(8453);const s={},c="Voice State Management",o={},l=[{value:"Understanding Voice State Flow",id:"understanding-voice-state-flow",level:2},{value:"Handling Voice Events",id:"handling-voice-events",level:2},{value:"Custom Voice State Handler",id:"custom-voice-state-handler",level:2},{value:"Automatic Voice Channel Management",id:"automatic-voice-channel-management",level:2},{value:"Voice Channel Tracking",id:"voice-channel-tracking",level:2},{value:"Best Practices",id:"best-practices",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"voice-state-management",children:"Voice State Management"})}),"\n",(0,a.jsx)(n.p,{children:"Learn how to handle voice state updates and manage voice connections in Yukino."}),"\n",(0,a.jsx)(n.h2,{id:"understanding-voice-state-flow",children:"Understanding Voice State Flow"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// Voice state flow:\r\n// 1. Discord.js emits voice state/server updates\r\n// 2. Connector receives and processes updates\r\n// 3. Node handles voice connection\r\n// 4. Player manages voice state\n"})}),"\n",(0,a.jsx)(n.h2,{id:"handling-voice-events",children:"Handling Voice Events"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"yukino.node.on('voiceStateUpdate', (state) => {\r\n  console.log('Voice state update:', {\r\n    guildId: state.guild_id,\r\n    channelId: state.channel_id,\r\n    sessionId: state.session_id\r\n  });\r\n});\r\n\r\nyukino.node.on('voiceServerUpdate', (server) => {\r\n  console.log('Voice server update:', {\r\n    guildId: server.guild_id,\r\n    endpoint: server.endpoint\r\n  });\r\n});\r\n\r\nyukino.node.on('voiceConnected', (player) => {\r\n  console.log(`Connected to voice in guild ${player.guildId}`);\r\n});\r\n\r\nyukino.node.on('voiceDisconnected', (player) => {\r\n  console.log(`Disconnected from voice in guild ${player.guildId}`);\r\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"custom-voice-state-handler",children:"Custom Voice State Handler"}),"\n",(0,a.jsx)(n.p,{children:"Create a handler to manage voice state:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"class VoiceStateHandler {\r\n  private players: Map<string, Player>;\r\n  private reconnectTimeouts: Map<string, NodeJS.Timeout>;\r\n  \r\n  constructor(private yukino: YukinoClient) {\r\n    this.players = new Map();\r\n    this.reconnectTimeouts = new Map();\r\n    \r\n    this.setupEventListeners();\r\n  }\r\n  \r\n  private setupEventListeners() {\r\n    this.yukino.node.on('voiceStateUpdate', this.handleVoiceState.bind(this));\r\n    this.yukino.node.on('voiceServerUpdate', this.handleVoiceServer.bind(this));\r\n    this.yukino.node.on('voiceDisconnected', this.handleDisconnect.bind(this));\r\n  }\r\n  \r\n  private async handleVoiceState(state: any) {\r\n    const player = this.yukino.getPlayer(state.guild_id);\r\n    if (!player) return;\r\n    \r\n    // Handle bot being moved to different channel\r\n    if (state.channel_id && state.channel_id !== player.voiceChannelId) {\r\n      player.voiceChannelId = state.channel_id;\r\n      // Optionally pause playback\r\n      await player.pause(true);\r\n    }\r\n    \r\n    // Handle bot being disconnected\r\n    if (!state.channel_id) {\r\n      this.scheduleReconnect(state.guild_id);\r\n    }\r\n  }\r\n  \r\n  private handleVoiceServer(server: any) {\r\n    const player = this.yukino.getPlayer(server.guild_id);\r\n    if (!player) return;\r\n    \r\n    // Clear any pending reconnect\r\n    this.clearReconnectTimeout(server.guild_id);\r\n  }\r\n  \r\n  private handleDisconnect(player: Player) {\r\n    this.scheduleReconnect(player.guildId);\r\n  }\r\n  \r\n  private scheduleReconnect(guildId: string, attempt = 1) {\r\n    this.clearReconnectTimeout(guildId);\r\n    \r\n    if (attempt > 5) {\r\n      console.error(`Failed to reconnect after 5 attempts in guild ${guildId}`);\r\n      return;\r\n    }\r\n    \r\n    const timeout = setTimeout(async () => {\r\n      const player = this.yukino.getPlayer(guildId);\r\n      if (!player) return;\r\n      \r\n      try {\r\n        await player.connect();\r\n      } catch (error) {\r\n        console.error('Reconnect failed:', error);\r\n        this.scheduleReconnect(guildId, attempt + 1);\r\n      }\r\n    }, Math.min(1000 * attempt, 5000));\r\n    \r\n    this.reconnectTimeouts.set(guildId, timeout);\r\n  }\r\n  \r\n  private clearReconnectTimeout(guildId: string) {\r\n    const timeout = this.reconnectTimeouts.get(guildId);\r\n    if (timeout) {\r\n      clearTimeout(timeout);\r\n      this.reconnectTimeouts.delete(guildId);\r\n    }\r\n  }\r\n  \r\n  // Handle cleanup\r\n  public destroy() {\r\n    for (const timeout of this.reconnectTimeouts.values()) {\r\n      clearTimeout(timeout);\r\n    }\r\n    this.reconnectTimeouts.clear();\r\n  }\r\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"automatic-voice-channel-management",children:"Automatic Voice Channel Management"}),"\n",(0,a.jsx)(n.p,{children:"Handle users joining/leaving voice channels:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"class VoiceChannelManager {\r\n  private leaveTimeouts: Map<string, NodeJS.Timeout>;\r\n  \r\n  constructor(private yukino: YukinoClient) {\r\n    this.leaveTimeouts = new Map();\r\n    this.setupEventListeners();\r\n  }\r\n  \r\n  private setupEventListeners() {\r\n    this.yukino.connector.client.on('voiceStateUpdate', async (oldState, newState) => {\r\n      const player = this.yukino.getPlayer(oldState.guild.id);\r\n      if (!player) return;\r\n      \r\n      // Handle user leaving the bot's channel\r\n      if (oldState.channelId === player.voiceChannelId && \r\n          newState.channelId !== player.voiceChannelId) {\r\n        this.handleUserLeave(player);\r\n      }\r\n      \r\n      // Handle user joining the bot's channel\r\n      if (newState.channelId === player.voiceChannelId) {\r\n        this.handleUserJoin(player);\r\n      }\r\n    });\r\n  }\r\n  \r\n  private handleUserLeave(player: Player) {\r\n    const channel = this.yukino.connector.client.channels.cache.get(\r\n      player.voiceChannelId\r\n    ) as VoiceChannel;\r\n    \r\n    // Count members in voice channel (excluding the bot)\r\n    const members = channel.members.size - 1;\r\n    \r\n    if (members === 0) {\r\n      // Schedule disconnect if no users remain\r\n      const timeout = setTimeout(() => {\r\n        if (player.playing) player.pause(true);\r\n        player.disconnect();\r\n      }, 5 * 60 * 1000); // 5 minutes\r\n      \r\n      this.leaveTimeouts.set(player.guildId, timeout);\r\n    }\r\n  }\r\n  \r\n  private handleUserJoin(player: Player) {\r\n    // Clear leave timeout when users join\r\n    const timeout = this.leaveTimeouts.get(player.guildId);\r\n    if (timeout) {\r\n      clearTimeout(timeout);\r\n      this.leaveTimeouts.delete(player.guildId);\r\n      \r\n      // Resume playback if it was paused\r\n      if (player.paused) player.pause(false);\r\n    }\r\n  }\r\n  \r\n  public destroy() {\r\n    for (const timeout of this.leaveTimeouts.values()) {\r\n      clearTimeout(timeout);\r\n    }\r\n    this.leaveTimeouts.clear();\r\n  }\r\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"voice-channel-tracking",children:"Voice Channel Tracking"}),"\n",(0,a.jsx)(n.p,{children:"Track voice channel states across the bot:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"class VoiceChannelTracker {\r\n  private channelStates: Map<string, {\r\n    members: Set<string>;\r\n    lastActivity: number;\r\n  }>;\r\n  \r\n  constructor(private yukino: YukinoClient) {\r\n    this.channelStates = new Map();\r\n    this.setupEventListeners();\r\n  }\r\n  \r\n  private setupEventListeners() {\r\n    // Track voice state changes\r\n    this.yukino.connector.client.on('voiceStateUpdate', (oldState, newState) => {\r\n      if (oldState.channelId) {\r\n        this.removeUserFromChannel(oldState.channelId, oldState.member!.id);\r\n      }\r\n      \r\n      if (newState.channelId) {\r\n        this.addUserToChannel(newState.channelId, newState.member!.id);\r\n      }\r\n    });\r\n    \r\n    // Track player creation\r\n    this.yukino.node.on('playerCreate', (player) => {\r\n      this.initializeChannelState(player.voiceChannelId);\r\n    });\r\n  }\r\n  \r\n  private initializeChannelState(channelId: string) {\r\n    const channel = this.yukino.connector.client.channels.cache.get(\r\n      channelId\r\n    ) as VoiceChannel;\r\n    \r\n    if (!channel) return;\r\n    \r\n    const members = new Set(\r\n      channel.members\r\n        .filter(member => !member.user.bot)\r\n        .map(member => member.id)\r\n    );\r\n    \r\n    this.channelStates.set(channelId, {\r\n      members,\r\n      lastActivity: Date.now()\r\n    });\r\n  }\r\n  \r\n  private addUserToChannel(channelId: string, userId: string) {\r\n    const state = this.channelStates.get(channelId) || {\r\n      members: new Set(),\r\n      lastActivity: Date.now()\r\n    };\r\n    \r\n    state.members.add(userId);\r\n    state.lastActivity = Date.now();\r\n    \r\n    this.channelStates.set(channelId, state);\r\n  }\r\n  \r\n  private removeUserFromChannel(channelId: string, userId: string) {\r\n    const state = this.channelStates.get(channelId);\r\n    if (!state) return;\r\n    \r\n    state.members.delete(userId);\r\n    state.lastActivity = Date.now();\r\n    \r\n    if (state.members.size === 0) {\r\n      this.channelStates.delete(channelId);\r\n    }\r\n  }\r\n  \r\n  public getChannelMembers(channelId: string): string[] {\r\n    return Array.from(this.channelStates.get(channelId)?.members || []);\r\n  }\r\n  \r\n  public getChannelActivity(channelId: string): number {\r\n    return this.channelStates.get(channelId)?.lastActivity || 0;\r\n  }\r\n  \r\n  public isChannelEmpty(channelId: string): boolean {\r\n    return this.getChannelMembers(channelId).length === 0;\r\n  }\r\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Handle voice state errors:"}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"player.on('error', (error) => {\r\n  if (error.message.includes('voice')) {\r\n    console.error('Voice connection error:', error);\r\n    // Attempt to reconnect\r\n    player.connect().catch(console.error);\r\n  }\r\n});\n"})}),"\n",(0,a.jsxs)(n.ol,{start:"2",children:["\n",(0,a.jsx)(n.li,{children:"Implement graceful disconnects:"}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"async function disconnectGracefully(player: Player) {\r\n  // Stop current track\r\n  await player.stop();\r\n  \r\n  // Clear queue\r\n  player.queue.clear();\r\n  \r\n  // Disconnect from voice\r\n  await player.disconnect();\r\n  \r\n  // Destroy player\r\n  await player.destroy();\r\n}\n"})}),"\n",(0,a.jsxs)(n.ol,{start:"3",children:["\n",(0,a.jsx)(n.li,{children:"Monitor voice connection health:"}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"class VoiceHealthMonitor {\r\n  private healthChecks: Map<string, {\r\n    lastPing: number;\r\n    failures: number;\r\n  }>;\r\n  \r\n  constructor(private yukino: YukinoClient) {\r\n    this.healthChecks = new Map();\r\n    this.startMonitoring();\r\n  }\r\n  \r\n  private startMonitoring() {\r\n    setInterval(() => {\r\n      for (const [guildId, player] of this.yukino.players) {\r\n        this.checkPlayerHealth(player);\r\n      }\r\n    }, 30000); // Check every 30 seconds\r\n  }\r\n  \r\n  private async checkPlayerHealth(player: Player) {\r\n    const health = this.healthChecks.get(player.guildId) || {\r\n      lastPing: Date.now(),\r\n      failures: 0\r\n    };\r\n    \r\n    try {\r\n      // Attempt to get voice state\r\n      await player.node.rest.getPlayer(\r\n        player.node.sessionId!,\r\n        player.guildId\r\n      );\r\n      \r\n      health.lastPing = Date.now();\r\n      health.failures = 0;\r\n    } catch (error) {\r\n      health.failures++;\r\n      \r\n      if (health.failures >= 3) {\r\n        // Attempt to reconnect after 3 failures\r\n        await player.connect().catch(console.error);\r\n        health.failures = 0;\r\n      }\r\n    }\r\n    \r\n    this.healthChecks.set(player.guildId, health);\r\n  }\r\n}\n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>c});var t=r(6540);const a={},i=t.createContext(a);function s(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);