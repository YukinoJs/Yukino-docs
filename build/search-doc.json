{"searchDocs":[{"title":"API Reference","type":0,"sectionRef":"#","url":"/docs/api/","content":"","keywords":"","version":"Next"},{"title":"Core Components​","type":1,"pageTitle":"API Reference","url":"/docs/api/#core-components","content":" ","version":"Next","tagName":"h2"},{"title":"YukinoClient​","type":1,"pageTitle":"API Reference","url":"/docs/api/#yukinoclient","content":" The main client class that handles connection to Lavalink and player management.  import { YukinoClient } from 'yukino';   ","version":"Next","tagName":"h3"},{"title":"Node​","type":1,"pageTitle":"API Reference","url":"/docs/api/#node","content":" Manages the WebSocket connection to Lavalink and handles events.  import { Node } from 'yukino';   ","version":"Next","tagName":"h3"},{"title":"Player​","type":1,"pageTitle":"API Reference","url":"/docs/api/#player","content":" Handles playback control and audio manipulation for a guild.  import { Player } from 'yukino';   ","version":"Next","tagName":"h3"},{"title":"Queue​","type":1,"pageTitle":"API Reference","url":"/docs/api/#queue","content":" Manages track queues for players.  import { Queue } from 'yukino';   ","version":"Next","tagName":"h3"},{"title":"Rest​","type":1,"pageTitle":"API Reference","url":"/docs/api/#rest","content":" Handles HTTP communication with the Lavalink server.  import { Rest } from 'yukino';   ","version":"Next","tagName":"h3"},{"title":"Connectors​","type":1,"pageTitle":"API Reference","url":"/docs/api/#connectors","content":" ","version":"Next","tagName":"h2"},{"title":"Connector​","type":1,"pageTitle":"API Reference","url":"/docs/api/#connector","content":" Base class for platform-specific connectors.  import { Connector } from 'yukino';   ","version":"Next","tagName":"h3"},{"title":"DiscordJSConnector​","type":1,"pageTitle":"API Reference","url":"/docs/api/#discordjsconnector","content":" Discord.js-specific implementation.  import { DiscordJSConnector } from 'yukino';   ","version":"Next","tagName":"h3"},{"title":"Filters & Effects​","type":1,"pageTitle":"API Reference","url":"/docs/api/#filters--effects","content":" ","version":"Next","tagName":"h2"},{"title":"FilterUtil​","type":1,"pageTitle":"API Reference","url":"/docs/api/#filterutil","content":" Utility class for audio filters and effects.  import { FilterUtil } from 'yukino';   ","version":"Next","tagName":"h3"},{"title":"Types & Interfaces​","type":1,"pageTitle":"API Reference","url":"/docs/api/#types--interfaces","content":" ","version":"Next","tagName":"h2"},{"title":"Events​","type":1,"pageTitle":"API Reference","url":"/docs/api/#events","content":" Event constants used throughout the library.  import { Events } from 'yukino';   ","version":"Next","tagName":"h3"},{"title":"LoadTypes​","type":1,"pageTitle":"API Reference","url":"/docs/api/#loadtypes","content":" Track loading result types.  import { LoadTypes } from 'yukino';   ","version":"Next","tagName":"h3"},{"title":"State​","type":1,"pageTitle":"API Reference","url":"/docs/api/#state","content":" Connection state constants.  import { State } from 'yukino';   ","version":"Next","tagName":"h3"},{"title":"PlayerStates​","type":1,"pageTitle":"API Reference","url":"/docs/api/#playerstates","content":" Player state constants.  import { PlayerStates } from 'yukino';   ","version":"Next","tagName":"h3"},{"title":"Configuration Interfaces​","type":1,"pageTitle":"API Reference","url":"/docs/api/#configuration-interfaces","content":" ConnectorOptionsNodeOptionsPlayerOptionsQueueOptionsRestOptions  ","version":"Next","tagName":"h3"},{"title":"Filter Interfaces​","type":1,"pageTitle":"API Reference","url":"/docs/api/#filter-interfaces","content":" FilterOptionsEqualizerBandKaraokeOptionsTimescaleOptionsFrequencyDepthOptionsRotationOptionsDistortionOptionsChannelMixOptionsLowPassOptions  ","version":"Next","tagName":"h3"},{"title":"Track Related​","type":1,"pageTitle":"API Reference","url":"/docs/api/#track-related","content":" TrackTrackInfoLoadTrackResponse  ","version":"Next","tagName":"h3"},{"title":"Utility Types​","type":1,"pageTitle":"API Reference","url":"/docs/api/#utility-types","content":" LavalinkEventNodeStats ","version":"Next","tagName":"h3"},{"title":"YukinoClient API","type":0,"sectionRef":"#","url":"/docs/api/yukino-client","content":"","keywords":"","version":"Next"},{"title":"Constructor​","type":1,"pageTitle":"YukinoClient API","url":"/docs/api/yukino-client#constructor","content":" constructor(client: Client, options: ConnectorOptions, nodeOptions: NodeOptions)   ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"YukinoClient API","url":"/docs/api/yukino-client#parameters","content":" client: Discord.js Client instanceoptions: ConnectorOptions for configuring the connectionnodeOptions: NodeOptions for configuring the Lavalink node  ","version":"Next","tagName":"h3"},{"title":"Example​","type":1,"pageTitle":"YukinoClient API","url":"/docs/api/yukino-client#example","content":" import { Client } from 'discord.js'; import { YukinoClient } from 'yukino'; const client = new Client({...}); const yukino = new YukinoClient(client, { client, auth: 'your-password', debug: true }, { name: 'main', url: 'localhost:2333', auth: 'your-password' });   ","version":"Next","tagName":"h3"},{"title":"Properties​","type":1,"pageTitle":"YukinoClient API","url":"/docs/api/yukino-client#properties","content":" ","version":"Next","tagName":"h2"},{"title":"connector​","type":1,"pageTitle":"YukinoClient API","url":"/docs/api/yukino-client#connector","content":" Type: ConnectorDescription: The connector instance used for voice state management  ","version":"Next","tagName":"h3"},{"title":"node​","type":1,"pageTitle":"YukinoClient API","url":"/docs/api/yukino-client#node","content":" Type: NodeDescription: The Lavalink node instance  ","version":"Next","tagName":"h3"},{"title":"players​","type":1,"pageTitle":"YukinoClient API","url":"/docs/api/yukino-client#players","content":" Type: Map&lt;string, Player&gt;Description: Map of all active players, keyed by guild IDRead-only  ","version":"Next","tagName":"h3"},{"title":"isReady​","type":1,"pageTitle":"YukinoClient API","url":"/docs/api/yukino-client#isready","content":" Type: booleanDescription: Whether the Lavalink node is connected and readyRead-only  ","version":"Next","tagName":"h3"},{"title":"Methods​","type":1,"pageTitle":"YukinoClient API","url":"/docs/api/yukino-client#methods","content":" ","version":"Next","tagName":"h2"},{"title":"connect()​","type":1,"pageTitle":"YukinoClient API","url":"/docs/api/yukino-client#connect","content":" Returns: voidDescription: Connects to the Lavalink node  yukino.connect();   ","version":"Next","tagName":"h3"},{"title":"createPlayer(options: PlayerOptions)​","type":1,"pageTitle":"YukinoClient API","url":"/docs/api/yukino-client#createplayeroptions-playeroptions","content":" Returns: PlayerDescription: Creates a new player for a guildThrows: Error if node is not ready  const player = yukino.createPlayer({ guildId: 'guild-id', voiceChannelId: 'channel-id', textChannelId: 'text-channel-id' });   ","version":"Next","tagName":"h3"},{"title":"getPlayer(guildId: string)​","type":1,"pageTitle":"YukinoClient API","url":"/docs/api/yukino-client#getplayerguildid-string","content":" Returns: Player | undefinedDescription: Gets an existing player for a guild  const player = yukino.getPlayer('guild-id'); if (player) { await player.play({...}); }   ","version":"Next","tagName":"h3"},{"title":"getQueue(guildId: string)​","type":1,"pageTitle":"YukinoClient API","url":"/docs/api/yukino-client#getqueueguildid-string","content":" Returns: Queue | undefinedDescription: Gets the queue for a guild's player  const queue = yukino.getQueue('guild-id'); if (queue) { console.log('Queue size:', queue.size); }   ","version":"Next","tagName":"h3"},{"title":"loadTrack(query: string)​","type":1,"pageTitle":"YukinoClient API","url":"/docs/api/yukino-client#loadtrackquery-string","content":" Returns: Promise&lt;LoadTrackResponse&gt;Description: Loads a track or playlist from a URL or search query  const result = await yukino.loadTrack('https://youtube.com/watch?v=...'); if (result.loadType === 'track') { await player.play({ track: result.data[0] }); }   ","version":"Next","tagName":"h3"},{"title":"destroy()​","type":1,"pageTitle":"YukinoClient API","url":"/docs/api/yukino-client#destroy","content":" Returns: voidDescription: Destroys all players and disconnects from Lavalink  yukino.destroy();   ","version":"Next","tagName":"h3"},{"title":"Events​","type":1,"pageTitle":"YukinoClient API","url":"/docs/api/yukino-client#events","content":" Events are emitted through the node instance:  yukino.node.on('nodeReady', () =&gt; { console.log('Connected to Lavalink!'); }); yukino.node.on('trackStart', (player, track) =&gt; { console.log(`Now playing: ${track.info.title}`); }); yukino.node.on('trackEnd', (player, track, reason) =&gt; { console.log(`Track ended: ${track.info.title}`); });   See Node Events for a complete list of events.  ","version":"Next","tagName":"h2"},{"title":"Type Definitions​","type":1,"pageTitle":"YukinoClient API","url":"/docs/api/yukino-client#type-definitions","content":" ","version":"Next","tagName":"h2"},{"title":"ConnectorOptions​","type":1,"pageTitle":"YukinoClient API","url":"/docs/api/yukino-client#connectoroptions","content":" interface ConnectorOptions { client: Client; auth: string; debug?: boolean; name?: string; host?: string; port?: number | string; url?: string; secure?: boolean; version?: string; sessionId?: string; }   ","version":"Next","tagName":"h3"},{"title":"NodeOptions​","type":1,"pageTitle":"YukinoClient API","url":"/docs/api/yukino-client#nodeoptions","content":" interface NodeOptions { name: string; url: string; auth: string; secure?: boolean; group?: string; reconnectInterval?: number; reconnectTries?: number; resumeKey?: string | null; resumeTimeout?: number; version?: string; debug?: boolean; }   ","version":"Next","tagName":"h3"},{"title":"PlayerOptions​","type":1,"pageTitle":"YukinoClient API","url":"/docs/api/yukino-client#playeroptions","content":" interface PlayerOptions { guildId: string; voiceChannelId: string; textChannelId?: string; deaf?: boolean; mute?: boolean; volume?: number; queueOptions?: QueueOptions; }   ","version":"Next","tagName":"h3"},{"title":"TypeScript Integration​","type":1,"pageTitle":"YukinoClient API","url":"/docs/api/yukino-client#typescript-integration","content":" YukinoClient adds type definitions to Discord.js's Client:  declare module 'discord.js' { interface Client { yukino: YukinoClient; } }   ","version":"Next","tagName":"h2"},{"title":"Debug Mode​","type":1,"pageTitle":"YukinoClient API","url":"/docs/api/yukino-client#debug-mode","content":" When debug is enabled in the options:  Connection state changes are loggedTrack loading information is displayedVoice state updates are trackedErrors are logged with stack traces  Example with debug enabled:  const yukino = new YukinoClient(client, { client, auth: 'password', debug: true // Enable debug logging }, { name: 'main', url: 'localhost:2333', auth: 'password' });  ","version":"Next","tagName":"h2"},{"title":"Player","type":0,"sectionRef":"#","url":"/docs/core/player","content":"","keywords":"","version":"Next"},{"title":"Creating a Player​","type":1,"pageTitle":"Player","url":"/docs/core/player#creating-a-player","content":" // Basic player creation const player = await yukino.createPlayer({ guildId: 'guild-id', voiceChannelId: 'channel-id' }); // Player with additional options const player = await yukino.createPlayer({ guildId: 'guild-id', voiceChannelId: 'channel-id', textChannelId: 'text-channel-id', selfDeaf: true, selfMute: false, volume: 100 });   ","version":"Next","tagName":"h2"},{"title":"Playback Control​","type":1,"pageTitle":"Player","url":"/docs/core/player#playback-control","content":" ","version":"Next","tagName":"h2"},{"title":"Basic Controls​","type":1,"pageTitle":"Player","url":"/docs/core/player#basic-controls","content":" // Start playing await player.play(); // Pause/Resume await player.pause(); await player.resume(); // Stop await player.stop(); // Destroy (cleanup) await player.destroy();   ","version":"Next","tagName":"h3"},{"title":"Track Management​","type":1,"pageTitle":"Player","url":"/docs/core/player#track-management","content":" // Play specific track await player.play({ track: trackData }); // Skip current track await player.skip(); // Seek to position await player.seek(60000); // Seek to 1 minute // Set volume (0-1000) await player.setVolume(100);   ","version":"Next","tagName":"h3"},{"title":"Playback Information​","type":1,"pageTitle":"Player","url":"/docs/core/player#playback-information","content":" // Get current track const track = player.current; console.log('Now playing:', track.info.title); // Get playback position const position = player.position; console.log('Current position:', position); // Check playback state console.log('Is playing:', player.playing); console.log('Is paused:', player.paused);   ","version":"Next","tagName":"h3"},{"title":"Queue Management​","type":1,"pageTitle":"Player","url":"/docs/core/player#queue-management","content":" ","version":"Next","tagName":"h2"},{"title":"Basic Queue Operations​","type":1,"pageTitle":"Player","url":"/docs/core/player#basic-queue-operations","content":" // Add tracks player.queue.add(track); player.queue.addMany([track1, track2]); // Remove tracks player.queue.remove(0); player.queue.clear(); // Get queue information console.log('Queue length:', player.queue.length); console.log('Current track:', player.queue.current); console.log('Next track:', player.queue.next);   ","version":"Next","tagName":"h3"},{"title":"Queue Manipulation​","type":1,"pageTitle":"Player","url":"/docs/core/player#queue-manipulation","content":" // Shuffle queue player.queue.shuffle(); // Move tracks player.queue.move(0, 2); // Move first track to third position // Filter tracks const filtered = player.queue.filter(track =&gt; track.info.length &lt; 300000 // Filter songs under 5 minutes );   ","version":"Next","tagName":"h3"},{"title":"Loop Modes​","type":1,"pageTitle":"Player","url":"/docs/core/player#loop-modes","content":" // Set loop mode player.setLoop('none'); // No loop player.setLoop('track'); // Loop current track player.setLoop('queue'); // Loop entire queue // Check current loop mode console.log('Loop mode:', player.loop);   ","version":"Next","tagName":"h3"},{"title":"Audio Effects​","type":1,"pageTitle":"Player","url":"/docs/core/player#audio-effects","content":" ","version":"Next","tagName":"h2"},{"title":"Volume Control​","type":1,"pageTitle":"Player","url":"/docs/core/player#volume-control","content":" // Set volume (0-1000) await player.setVolume(100); // Fade volume await player.fade({ from: 100, to: 50, duration: 5000 // 5 seconds });   ","version":"Next","tagName":"h3"},{"title":"Filters​","type":1,"pageTitle":"Player","url":"/docs/core/player#filters","content":" // Apply single filter await player.setFilter('equalizer', [ { band: 0, gain: 0.3 }, { band: 1, gain: 0.2 } ]); // Apply multiple filters await player.setFilters({ equalizer: [ { band: 0, gain: 0.3 }, { band: 1, gain: 0.2 } ], timescale: { speed: 1.2, pitch: 1.1, rate: 1.0 }, tremolo: { frequency: 2.0, depth: 0.5 } }); // Reset filters await player.resetFilter('equalizer'); await player.resetFilters();   ","version":"Next","tagName":"h3"},{"title":"Voice Connection​","type":1,"pageTitle":"Player","url":"/docs/core/player#voice-connection","content":" ","version":"Next","tagName":"h2"},{"title":"Voice State Management​","type":1,"pageTitle":"Player","url":"/docs/core/player#voice-state-management","content":" // Update voice state await player.updateVoice({ channelId: 'new-channel-id', selfDeaf: true, selfMute: false }); // Disconnect from voice await player.disconnect(); // Reconnect to voice await player.reconnect();   ","version":"Next","tagName":"h3"},{"title":"Voice Events​","type":1,"pageTitle":"Player","url":"/docs/core/player#voice-events","content":" // Voice state update player.on('voiceStateUpdate', (state) =&gt; { console.log('Voice state changed:', state); }); // Voice disconnected player.on('voiceDisconnected', (reason) =&gt; { console.log('Disconnected:', reason); });   ","version":"Next","tagName":"h3"},{"title":"Event Handling​","type":1,"pageTitle":"Player","url":"/docs/core/player#event-handling","content":" ","version":"Next","tagName":"h2"},{"title":"Playback Events​","type":1,"pageTitle":"Player","url":"/docs/core/player#playback-events","content":" // Track started player.on('trackStart', (track) =&gt; { console.log('Now playing:', track.info.title); }); // Track ended player.on('trackEnd', (track) =&gt; { console.log('Finished playing:', track.info.title); }); // Track stuck player.on('trackStuck', (track, thresholdMs) =&gt; { console.warn(`Track stuck for ${thresholdMs}ms`); }); // Track error player.on('trackError', (track, error) =&gt; { console.error('Playback error:', error); });   ","version":"Next","tagName":"h3"},{"title":"State Events​","type":1,"pageTitle":"Player","url":"/docs/core/player#state-events","content":" // Player state update player.on('stateUpdate', (oldState, newState) =&gt; { console.log('State changed from', oldState, 'to', newState); }); // Player destroyed player.on('destroyed', () =&gt; { console.log('Player cleaned up'); });   ","version":"Next","tagName":"h3"},{"title":"Advanced Usage​","type":1,"pageTitle":"Player","url":"/docs/core/player#advanced-usage","content":" ","version":"Next","tagName":"h2"},{"title":"Custom Player Options​","type":1,"pageTitle":"Player","url":"/docs/core/player#custom-player-options","content":" // Create player with custom options const player = await yukino.createPlayer({ guildId: 'guild-id', voiceChannelId: 'channel-id', options: { inactivityTimeout: 300000, // 5 minutes volumeDecrementer: 0.75, // Reduce volume by 25% bufferingTimeout: 5000 // 5 seconds buffer timeout } });   ","version":"Next","tagName":"h3"},{"title":"Playback Statistics​","type":1,"pageTitle":"Player","url":"/docs/core/player#playback-statistics","content":" // Get detailed stats const stats = player.stats; console.log('Frames sent:', stats.framesSent); console.log('Frames nulled:', stats.framesNulled); console.log('Frames deficit:', stats.framesDeficit); // Monitor frame stats player.on('stats', (stats) =&gt; { if (stats.framesNulled &gt; 100) { console.warn('Poor connection quality'); } });   ","version":"Next","tagName":"h3"},{"title":"Resource Management​","type":1,"pageTitle":"Player","url":"/docs/core/player#resource-management","content":" // Clean up resources await player.cleanup({ removeListeners: true, destroyQueue: true }); // Monitor resource usage player.on('debug', (message) =&gt; { console.debug('[Player Debug]:', message); });  ","version":"Next","tagName":"h3"},{"title":"Node","type":0,"sectionRef":"#","url":"/docs/core/node","content":"","keywords":"","version":"Next"},{"title":"Node Configuration​","type":1,"pageTitle":"Node","url":"/docs/core/node#node-configuration","content":" interface NodeOptions { name: string; // Unique identifier for the node url: string; // URL of the Lavalink server auth: string; // Password for the Lavalink server secure?: boolean; // Whether to use WSS/HTTPS group?: string; // Group identifier for region-based routing retryAmount?: number; // Number of reconnection attempts retryDelay?: number; // Delay between retries in milliseconds }   ","version":"Next","tagName":"h2"},{"title":"Node States​","type":1,"pageTitle":"Node","url":"/docs/core/node#node-states","content":" A node can be in one of these states:  CONNECTING - Initial connection attemptCONNECTED - Successfully connectedDISCONNECTED - Connection lostRECONNECTING - Attempting to reconnectDESTROYED - Node has been destroyed  ","version":"Next","tagName":"h2"},{"title":"Connection Management​","type":1,"pageTitle":"Node","url":"/docs/core/node#connection-management","content":" ","version":"Next","tagName":"h2"},{"title":"Manual Connection​","type":1,"pageTitle":"Node","url":"/docs/core/node#manual-connection","content":" // Connect to a node await node.connect(); // Disconnect from a node await node.disconnect(); // Destroy a node (permanent disconnect) await node.destroy();   ","version":"Next","tagName":"h3"},{"title":"Auto-Reconnection​","type":1,"pageTitle":"Node","url":"/docs/core/node#auto-reconnection","content":" Nodes automatically attempt to reconnect when disconnected:  // Configure reconnection behavior const node = yukino.addNode({ name: 'main', url: 'localhost:2333', auth: 'password', retryAmount: 5, // Try 5 times retryDelay: 5000 // Wait 5 seconds between attempts }); // Listen for reconnection attempts node.on('reconnecting', (attempt) =&gt; { console.log(`Reconnection attempt ${attempt}`); });   ","version":"Next","tagName":"h3"},{"title":"Track Loading​","type":1,"pageTitle":"Node","url":"/docs/core/node#track-loading","content":" ","version":"Next","tagName":"h2"},{"title":"Load Tracks​","type":1,"pageTitle":"Node","url":"/docs/core/node#load-tracks","content":" // Load a single track const track = await node.loadTrack('youtube:dQw4w9WgXcQ'); // Load a playlist const playlist = await node.loadTrack('youtube:PLplaylist_id'); // Search for tracks const results = await node.loadTrack('ytsearch:never gonna give you up');   ","version":"Next","tagName":"h3"},{"title":"Track Loading Response​","type":1,"pageTitle":"Node","url":"/docs/core/node#track-loading-response","content":" interface LoadTrackResponse { loadType: 'TRACK_LOADED' | 'PLAYLIST_LOADED' | 'SEARCH_RESULT' | 'NO_MATCHES' | 'LOAD_FAILED'; playlistInfo?: { name: string; selectedTrack: number; }; tracks: Track[]; exception?: { message: string; severity: 'COMMON' | 'SUSPICIOUS' | 'FAULT'; }; }   ","version":"Next","tagName":"h3"},{"title":"Resource Management​","type":1,"pageTitle":"Node","url":"/docs/core/node#resource-management","content":" ","version":"Next","tagName":"h2"},{"title":"Memory Management​","type":1,"pageTitle":"Node","url":"/docs/core/node#memory-management","content":" // Get node stats const stats = await node.getStats(); console.log('Memory used:', stats.memory.used); console.log('Memory allocated:', stats.memory.allocated); console.log('Memory reservable:', stats.memory.reservable); // Monitor memory usage node.on('stats', (stats) =&gt; { const memoryUsage = (stats.memory.used / stats.memory.allocated) * 100; if (memoryUsage &gt; 90) { console.warn(`High memory usage on node ${node.name}: ${memoryUsage}%`); } });   ","version":"Next","tagName":"h3"},{"title":"CPU Management​","type":1,"pageTitle":"Node","url":"/docs/core/node#cpu-management","content":" // Get CPU stats const stats = await node.getStats(); console.log('CPU cores:', stats.cpu.cores); console.log('System load:', stats.cpu.systemLoad); console.log('Lavalink load:', stats.cpu.lavalinkLoad); // Monitor CPU usage node.on('stats', (stats) =&gt; { if (stats.cpu.systemLoad &gt; 80) { console.warn(`High CPU usage on node ${node.name}`); } });   ","version":"Next","tagName":"h3"},{"title":"Error Handling​","type":1,"pageTitle":"Node","url":"/docs/core/node#error-handling","content":" ","version":"Next","tagName":"h2"},{"title":"Connection Errors​","type":1,"pageTitle":"Node","url":"/docs/core/node#connection-errors","content":" node.on('error', (error) =&gt; { if (error.code === 'ECONNREFUSED') { console.error('Failed to connect to Lavalink server'); } else if (error.code === 'AUTHENTICATION_FAILED') { console.error('Invalid password'); } });   ","version":"Next","tagName":"h3"},{"title":"Track Load Errors​","type":1,"pageTitle":"Node","url":"/docs/core/node#track-load-errors","content":" try { const result = await node.loadTrack('invalid:url'); } catch (error) { if (error.loadType === 'LOAD_FAILED') { console.error('Failed to load track:', error.exception.message); } }   ","version":"Next","tagName":"h3"},{"title":"Performance Monitoring​","type":1,"pageTitle":"Node","url":"/docs/core/node#performance-monitoring","content":" ","version":"Next","tagName":"h2"},{"title":"Frame Statistics​","type":1,"pageTitle":"Node","url":"/docs/core/node#frame-statistics","content":" node.on('stats', (stats) =&gt; { // Monitor frame statistics console.log('Frames sent:', stats.frames.sent); console.log('Frames nulled:', stats.frames.nulled); console.log('Frames deficit:', stats.frames.deficit); });   ","version":"Next","tagName":"h3"},{"title":"Player Statistics​","type":1,"pageTitle":"Node","url":"/docs/core/node#player-statistics","content":" node.on('stats', (stats) =&gt; { // Monitor player counts console.log('Total players:', stats.players); console.log('Playing players:', stats.playingPlayers); });   ","version":"Next","tagName":"h3"},{"title":"Advanced Features​","type":1,"pageTitle":"Node","url":"/docs/core/node#advanced-features","content":" ","version":"Next","tagName":"h2"},{"title":"Custom REST Routes​","type":1,"pageTitle":"Node","url":"/docs/core/node#custom-rest-routes","content":" // Define custom REST route node.defineRoute({ method: 'GET', path: '/custom/route', handler: async () =&gt; { // Custom logic return { status: 'ok' }; } }); // Use custom route const response = await node.makeRequest('/custom/route');   ","version":"Next","tagName":"h3"},{"title":"Version Compatibility​","type":1,"pageTitle":"Node","url":"/docs/core/node#version-compatibility","content":" // Check Lavalink version const version = await node.getVersion(); console.log('Lavalink version:', version); // Check version compatibility if (version.major &lt; 3) { console.warn('This version of Lavalink is not fully supported'); }   ","version":"Next","tagName":"h3"},{"title":"Load Balancing​","type":1,"pageTitle":"Node","url":"/docs/core/node#load-balancing","content":" // Get node penalties const penalties = node.penalties; console.log('CPU penalty:', penalties.cpu); console.log('Memory penalty:', penalties.memory); console.log('Deficit penalty:', penalties.deficit); console.log('Total penalty:', penalties.total); // Custom penalty calculation node.setPenaltyProvider(() =&gt; { const stats = node.stats; return (stats.cpu.systemLoad * 0.6) + (stats.memory.used / stats.memory.allocated * 0.4); });  ","version":"Next","tagName":"h3"},{"title":"REST API","type":0,"sectionRef":"#","url":"/docs/api/rest","content":"","keywords":"","version":"Next"},{"title":"Constructor​","type":1,"pageTitle":"REST API","url":"/docs/api/rest#constructor","content":" import { Rest } from 'yukino'; const rest = new Rest({ url: 'localhost:2333', auth: 'your-password', secure: false, // Use HTTPS timeout: 15000, // Request timeout in ms version: '4', // Lavalink API version debug: false // Enable debug logging });   ","version":"Next","tagName":"h2"},{"title":"Track Loading​","type":1,"pageTitle":"REST API","url":"/docs/api/rest#track-loading","content":" ","version":"Next","tagName":"h2"},{"title":"loadTracks(identifier: string)​","type":1,"pageTitle":"REST API","url":"/docs/api/rest#loadtracksidentifier-string","content":" Load tracks from URLs or search queries.  // Load from URL const result = await rest.loadTracks('https://youtube.com/watch?v=...'); // Search YouTube const searchResult = await rest.loadTracks('ytsearch:your search query'); // Handle different result types switch (result.loadType) { case 'track': console.log('Single track:', result.data[0].info.title); break; case 'playlist': console.log('Playlist:', result.playlistInfo?.name); console.log('Track count:', result.data?.length); break; case 'search': console.log('Search results:', result.data?.length); break; case 'empty': console.log('No matches found'); break; case 'error': console.error('Error:', result.exception?.message); break; }   ","version":"Next","tagName":"h3"},{"title":"decodeTrack(encodedTrack: string)​","type":1,"pageTitle":"REST API","url":"/docs/api/rest#decodetrackencodedtrack-string","content":" Decode a base64 track string into track information.  const trackInfo = await rest.decodeTrack('base64trackstring...'); console.log('Track title:', trackInfo.title);   ","version":"Next","tagName":"h3"},{"title":"encodeTrack(track: Record<string, any>)​","type":1,"pageTitle":"REST API","url":"/docs/api/rest#encodetracktrack-recordstring-any","content":" Encode track information into a base64 string.  const encoded = await rest.encodeTrack({ title: 'Song Name', author: 'Artist', length: 180000 });   ","version":"Next","tagName":"h3"},{"title":"Player Management​","type":1,"pageTitle":"REST API","url":"/docs/api/rest#player-management","content":" ","version":"Next","tagName":"h2"},{"title":"updatePlayer(sessionId: string, guildId: string, data: any)​","type":1,"pageTitle":"REST API","url":"/docs/api/rest#updateplayersessionid-string-guildid-string-data-any","content":" Update a player's state via REST API.  await rest.updatePlayer('session-id', 'guild-id', { track: { encoded: 'base64track...' }, volume: 100, paused: false });   ","version":"Next","tagName":"h3"},{"title":"getPlayer(sessionId: string, guildId: string)​","type":1,"pageTitle":"REST API","url":"/docs/api/rest#getplayersessionid-string-guildid-string","content":" Get information about a specific player.  const player = await rest.getPlayer('session-id', 'guild-id'); console.log('Current track:', player.track);   ","version":"Next","tagName":"h3"},{"title":"getPlayers(sessionId: string)​","type":1,"pageTitle":"REST API","url":"/docs/api/rest#getplayerssessionid-string","content":" Get all players in a session.  const players = await rest.getPlayers('session-id'); console.log('Active players:', players.length);   ","version":"Next","tagName":"h3"},{"title":"destroyPlayer(sessionId: string, guildId: string)​","type":1,"pageTitle":"REST API","url":"/docs/api/rest#destroyplayersessionid-string-guildid-string","content":" Destroy a player instance.  await rest.destroyPlayer('session-id', 'guild-id');   ","version":"Next","tagName":"h3"},{"title":"Session Management​","type":1,"pageTitle":"REST API","url":"/docs/api/rest#session-management","content":" ","version":"Next","tagName":"h2"},{"title":"updateSession(sessionId: string, resumeKey: string, timeout: number)​","type":1,"pageTitle":"REST API","url":"/docs/api/rest#updatesessionsessionid-string-resumekey-string-timeout-number","content":" Update session configuration for resuming.  await rest.updateSession( 'session-id', 'resume-key', 60 // Resume timeout in seconds );   ","version":"Next","tagName":"h3"},{"title":"getSessions()​","type":1,"pageTitle":"REST API","url":"/docs/api/rest#getsessions","content":" Get all active Lavalink sessions.  const sessions = await rest.getSessions(); console.log('Active sessions:', sessions.length);   ","version":"Next","tagName":"h3"},{"title":"getSession(sessionId: string)​","type":1,"pageTitle":"REST API","url":"/docs/api/rest#getsessionsessionid-string","content":" Get information about a specific session.  const session = await rest.getSession('session-id'); console.log('Session details:', session);   ","version":"Next","tagName":"h3"},{"title":"Server Information​","type":1,"pageTitle":"REST API","url":"/docs/api/rest#server-information","content":" ","version":"Next","tagName":"h2"},{"title":"version()​","type":1,"pageTitle":"REST API","url":"/docs/api/rest#version","content":" Get Lavalink server version.  const version = await rest.version(); console.log('Lavalink version:', version);   ","version":"Next","tagName":"h3"},{"title":"info()​","type":1,"pageTitle":"REST API","url":"/docs/api/rest#info","content":" Get detailed server information.  const info = await rest.info(); console.log('Server info:', info);   ","version":"Next","tagName":"h3"},{"title":"stats()​","type":1,"pageTitle":"REST API","url":"/docs/api/rest#stats","content":" Get server statistics.  const stats = await rest.stats(); console.log('CPU Usage:', stats.cpu.systemLoad); console.log('Memory Used:', stats.memory.used);   ","version":"Next","tagName":"h3"},{"title":"Error Handling​","type":1,"pageTitle":"REST API","url":"/docs/api/rest#error-handling","content":" The REST client includes comprehensive error handling:  try { await rest.loadTracks('invalid://url'); } catch (error) { console.error('Status:', error.response?.status); console.error('Message:', error.response?.data); }   ","version":"Next","tagName":"h2"},{"title":"Debug Mode​","type":1,"pageTitle":"REST API","url":"/docs/api/rest#debug-mode","content":" When debug mode is enabled:  const rest = new Rest({ url: 'localhost:2333', auth: 'password', debug: true // Enable debug logging });   You'll see detailed logs for:  All HTTP requests and responsesRequest timing informationError details with stack tracesDecoded track informationServer status updates  ","version":"Next","tagName":"h2"},{"title":"Request Configuration​","type":1,"pageTitle":"REST API","url":"/docs/api/rest#request-configuration","content":" ","version":"Next","tagName":"h2"},{"title":"Base Configuration​","type":1,"pageTitle":"REST API","url":"/docs/api/rest#base-configuration","content":" const rest = new Rest({ url: 'localhost:2333', auth: 'password', secure: false, timeout: 15000, version: '4' });   ","version":"Next","tagName":"h3"},{"title":"Using HTTPS​","type":1,"pageTitle":"REST API","url":"/docs/api/rest#using-https","content":" const rest = new Rest({ url: 'example.com:2333', auth: 'password', secure: true // Use HTTPS });   ","version":"Next","tagName":"h3"},{"title":"Custom Timeout​","type":1,"pageTitle":"REST API","url":"/docs/api/rest#custom-timeout","content":" const rest = new Rest({ url: 'localhost:2333', auth: 'password', timeout: 30000 // 30 seconds });   ","version":"Next","tagName":"h3"},{"title":"Best Practices​","type":1,"pageTitle":"REST API","url":"/docs/api/rest#best-practices","content":" Handle rate limits gracefully:  async function loadTrackWithRetry(identifier: string, maxRetries = 3) { for (let i = 0; i &lt; maxRetries; i++) { try { return await rest.loadTracks(identifier); } catch (error) { if (error.response?.status === 429) { const retryAfter = error.response.headers['retry-after']; await new Promise(r =&gt; setTimeout(r, retryAfter * 1000)); continue; } throw error; } } }   Process REST events properly:  rest.processRestEvents(node, response);   Use timeouts appropriately:  const rest = new Rest({ url: 'localhost:2333', auth: 'password', timeout: 15000 // Default }); // For long operations rest.timeout = 30000;  ","version":"Next","tagName":"h2"},{"title":"Queue","type":0,"sectionRef":"#","url":"/docs/core/queue","content":"","keywords":"","version":"Next"},{"title":"Queue Structure​","type":1,"pageTitle":"Queue","url":"/docs/core/queue#queue-structure","content":" A queue in Yukino has these key components:  Current trackTrack historyUpcoming tracksLoop modeShuffle state  ","version":"Next","tagName":"h2"},{"title":"Basic Operations​","type":1,"pageTitle":"Queue","url":"/docs/core/queue#basic-operations","content":" ","version":"Next","tagName":"h2"},{"title":"Adding Tracks​","type":1,"pageTitle":"Queue","url":"/docs/core/queue#adding-tracks","content":" // Add a single track queue.add(track); // Add multiple tracks queue.addMany([track1, track2, track3]); // Add track at specific position queue.add(track, { position: 2 }); // Add with options queue.add(track, { position: 0, // Position in queue immediate: true, // Play immediately unshift: true // Add to start of queue });   ","version":"Next","tagName":"h3"},{"title":"Removing Tracks​","type":1,"pageTitle":"Queue","url":"/docs/core/queue#removing-tracks","content":" // Remove by position queue.remove(0); // Remove range queue.remove(0, 3); // Remove first 3 tracks // Remove by predicate queue.remove(track =&gt; track.info.length &gt; 600000); // Remove tracks &gt; 10min // Clear queue queue.clear();   ","version":"Next","tagName":"h3"},{"title":"Queue Navigation​","type":1,"pageTitle":"Queue","url":"/docs/core/queue#queue-navigation","content":" ","version":"Next","tagName":"h2"},{"title":"Track Access​","type":1,"pageTitle":"Queue","url":"/docs/core/queue#track-access","content":" // Get current track const current = queue.current; // Get next track const next = queue.next; // Get previous track const previous = queue.previous; // Get track at position const track = queue.at(2);   ","version":"Next","tagName":"h3"},{"title":"Queue Information​","type":1,"pageTitle":"Queue","url":"/docs/core/queue#queue-information","content":" // Get queue length console.log('Tracks in queue:', queue.length); // Get queue duration console.log('Total duration:', queue.duration); // Check if queue has tracks console.log('Has tracks:', queue.hasTrack); console.log('Is empty:', queue.isEmpty);   ","version":"Next","tagName":"h3"},{"title":"Queue Manipulation​","type":1,"pageTitle":"Queue","url":"/docs/core/queue#queue-manipulation","content":" ","version":"Next","tagName":"h2"},{"title":"Reordering​","type":1,"pageTitle":"Queue","url":"/docs/core/queue#reordering","content":" // Move track queue.move(0, 2); // Move first track to third position // Swap tracks queue.swap(1, 3); // Swap second and fourth tracks // Reverse queue queue.reverse();   ","version":"Next","tagName":"h3"},{"title":"Shuffling​","type":1,"pageTitle":"Queue","url":"/docs/core/queue#shuffling","content":" // Shuffle entire queue queue.shuffle(); // Shuffle range queue.shuffle(0, 5); // Shuffle first 5 tracks // Shuffle with options queue.shuffle(undefined, { startFrom: 1, // Start shuffling from second track preserveFirst: true // Keep first track in place });   ","version":"Next","tagName":"h3"},{"title":"Loop Modes​","type":1,"pageTitle":"Queue","url":"/docs/core/queue#loop-modes","content":" ","version":"Next","tagName":"h2"},{"title":"Setting Loop Mode​","type":1,"pageTitle":"Queue","url":"/docs/core/queue#setting-loop-mode","content":" // Set loop mode queue.setLoop('none'); // No looping queue.setLoop('track'); // Loop current track queue.setLoop('queue'); // Loop entire queue // Check current loop mode console.log('Loop mode:', queue.loop);   ","version":"Next","tagName":"h3"},{"title":"Loop Behavior​","type":1,"pageTitle":"Queue","url":"/docs/core/queue#loop-behavior","content":" // Track loop example queue.on('trackEnd', () =&gt; { if (queue.loop === 'track') { // Current track will automatically replay console.log('Replaying:', queue.current.info.title); } }); // Queue loop example queue.on('queueEnd', () =&gt; { if (queue.loop === 'queue') { // Queue will automatically restart console.log('Restarting queue'); } });   ","version":"Next","tagName":"h3"},{"title":"History Management​","type":1,"pageTitle":"Queue","url":"/docs/core/queue#history-management","content":" ","version":"Next","tagName":"h2"},{"title":"Track History​","type":1,"pageTitle":"Queue","url":"/docs/core/queue#track-history","content":" // Get history const history = queue.history; // Get last played track const lastPlayed = queue.history.last; // Get specific track from history const trackFromHistory = queue.history.at(-2); // Second to last track // Clear history queue.history.clear();   ","version":"Next","tagName":"h3"},{"title":"Navigation Through History​","type":1,"pageTitle":"Queue","url":"/docs/core/queue#navigation-through-history","content":" // Go back to previous track queue.previous(); // Go forward if available queue.next(); // Check if navigation is possible console.log('Can go back:', queue.canGoBack); console.log('Can go forward:', queue.canGoForward);   ","version":"Next","tagName":"h3"},{"title":"Advanced Features​","type":1,"pageTitle":"Queue","url":"/docs/core/queue#advanced-features","content":" ","version":"Next","tagName":"h2"},{"title":"Queue Filtering​","type":1,"pageTitle":"Queue","url":"/docs/core/queue#queue-filtering","content":" // Filter tracks const filtered = queue.filter(track =&gt; track.info.length &lt; 300000 // Filter songs under 5 minutes ); // Find tracks const found = queue.find(track =&gt; track.info.title.includes('keyword') ); // Map tracks const titles = queue.map(track =&gt; track.info.title);   ","version":"Next","tagName":"h3"},{"title":"Queue Events​","type":1,"pageTitle":"Queue","url":"/docs/core/queue#queue-events","content":" // Track added queue.on('trackAdd', (track, position) =&gt; { console.log(`Added ${track.info.title} at position ${position}`); }); // Track removed queue.on('trackRemove', (track, position) =&gt; { console.log(`Removed ${track.info.title} from position ${position}`); }); // Queue shuffled queue.on('shuffle', () =&gt; { console.log('Queue has been shuffled'); });   ","version":"Next","tagName":"h3"},{"title":"State Management​","type":1,"pageTitle":"Queue","url":"/docs/core/queue#state-management","content":" // Save queue state const state = queue.save(); // Load queue state queue.load(state); // Reset queue queue.reset();   ","version":"Next","tagName":"h3"},{"title":"Custom Sorting​","type":1,"pageTitle":"Queue","url":"/docs/core/queue#custom-sorting","content":" // Sort by duration queue.sort((a, b) =&gt; a.info.length - b.info.length); // Sort by title queue.sort((a, b) =&gt; a.info.title.localeCompare(b.info.title)); // Sort with custom criteria queue.sort((a, b) =&gt; { const weightA = getTrackWeight(a); const weightB = getTrackWeight(b); return weightA - weightB; });   ","version":"Next","tagName":"h3"},{"title":"Performance Optimization​","type":1,"pageTitle":"Queue","url":"/docs/core/queue#performance-optimization","content":" ","version":"Next","tagName":"h2"},{"title":"Batch Operations​","type":1,"pageTitle":"Queue","url":"/docs/core/queue#batch-operations","content":" // Batch add tracks queue.transaction(() =&gt; { tracks.forEach(track =&gt; queue.add(track)); }); // Batch remove tracks queue.transaction(() =&gt; { tracksToRemove.forEach(track =&gt; queue.remove(track)); });   ","version":"Next","tagName":"h3"},{"title":"Memory Management​","type":1,"pageTitle":"Queue","url":"/docs/core/queue#memory-management","content":" // Trim history to save memory queue.history.trim(10); // Keep only last 10 tracks // Clear unused resources queue.cleanup();  ","version":"Next","tagName":"h3"},{"title":"Types Reference","type":0,"sectionRef":"#","url":"/docs/api/types","content":"","keywords":"","version":"Next"},{"title":"Constants​","type":1,"pageTitle":"Types Reference","url":"/docs/api/types#constants","content":" ","version":"Next","tagName":"h2"},{"title":"Events​","type":1,"pageTitle":"Types Reference","url":"/docs/api/types#events","content":" enum Events { // Node events NODE_READY = 'nodeReady', NODE_ERROR = 'nodeError', NODE_CLOSED = 'nodeClosed', NODE_RECONNECT = 'nodeReconnect', NODE_STATS = 'nodeStats', NODE_EVENT = 'nodeEvent', // Player events PLAYER_CREATE = 'playerCreate', PLAYER_DESTROY = 'playerDestroy', PLAYER_UPDATE = 'playerUpdate', // Track events TRACK_START = 'trackStart', TRACK_END = 'trackEnd', TRACK_ERROR = 'trackError', TRACK_STUCK = 'trackStuck', // Voice events VOICE_CONNECTED = 'voiceConnected', VOICE_DISCONNECTED = 'voiceDisconnected', VOICE_STATE_UPDATE = 'voiceStateUpdate', VOICE_SERVER_UPDATE = 'voiceServerUpdate', // WebSocket events WS_CLOSED = 'wsClosed', WS_ERROR = 'wsError', WS_OPEN = 'wsOpen' }   ","version":"Next","tagName":"h3"},{"title":"LoadTypes​","type":1,"pageTitle":"Types Reference","url":"/docs/api/types#loadtypes","content":" enum LoadTypes { TRACK_LOADED = 'track', PLAYLIST_LOADED = 'playlist', SEARCH_RESULT = 'search', NO_MATCHES = 'empty', LOAD_FAILED = 'error' }   ","version":"Next","tagName":"h3"},{"title":"State​","type":1,"pageTitle":"Types Reference","url":"/docs/api/types#state","content":" enum State { CONNECTING = 0, CONNECTED = 1, DISCONNECTING = 2, DISCONNECTED = 3, RECONNECTING = 4 }   ","version":"Next","tagName":"h3"},{"title":"PlayerStates​","type":1,"pageTitle":"Types Reference","url":"/docs/api/types#playerstates","content":" enum PlayerStates { PLAYING = 'playing', PAUSED = 'paused', IDLE = 'idle' }   ","version":"Next","tagName":"h3"},{"title":"Configuration Interfaces​","type":1,"pageTitle":"Types Reference","url":"/docs/api/types#configuration-interfaces","content":" ","version":"Next","tagName":"h2"},{"title":"ConnectorOptions​","type":1,"pageTitle":"Types Reference","url":"/docs/api/types#connectoroptions","content":" interface ConnectorOptions { client: Client; name?: string; host?: string; port?: number | string; url?: string; auth: string; secure?: boolean; version?: string; sessionId?: string; debug?: boolean; }   ","version":"Next","tagName":"h3"},{"title":"NodeOptions​","type":1,"pageTitle":"Types Reference","url":"/docs/api/types#nodeoptions","content":" interface NodeOptions { name: string; url: string; auth: string; secure?: boolean; group?: string; reconnectInterval?: number; reconnectTries?: number; resumeKey?: string | null; resumeTimeout?: number; version?: string; debug?: boolean; }   ","version":"Next","tagName":"h3"},{"title":"PlayerOptions​","type":1,"pageTitle":"Types Reference","url":"/docs/api/types#playeroptions","content":" interface PlayerOptions { guildId: string; textChannelId?: string; voiceChannelId: string; deaf?: boolean; mute?: boolean; volume?: number; queueOptions?: QueueOptions; }   ","version":"Next","tagName":"h3"},{"title":"QueueOptions​","type":1,"pageTitle":"Types Reference","url":"/docs/api/types#queueoptions","content":" interface QueueOptions { maxSize?: number; defaultVolume?: number; durationType?: &quot;ms&quot; | &quot;s&quot;; }   ","version":"Next","tagName":"h3"},{"title":"RestOptions​","type":1,"pageTitle":"Types Reference","url":"/docs/api/types#restoptions","content":" interface RestOptions { url: string; auth: string; secure?: boolean; timeout?: number; version?: string; debug?: boolean; }   ","version":"Next","tagName":"h3"},{"title":"Filter Interfaces​","type":1,"pageTitle":"Types Reference","url":"/docs/api/types#filter-interfaces","content":" ","version":"Next","tagName":"h2"},{"title":"FilterOptions​","type":1,"pageTitle":"Types Reference","url":"/docs/api/types#filteroptions","content":" interface FilterOptions { volume?: number; equalizer?: EqualizerBand[]; karaoke?: KaraokeOptions; timescale?: TimescaleOptions; tremolo?: FrequencyDepthOptions; vibrato?: FrequencyDepthOptions; rotation?: RotationOptions; distortion?: DistortionOptions; channelMix?: ChannelMixOptions; lowPass?: LowPassOptions; }   ","version":"Next","tagName":"h3"},{"title":"EqualizerBand​","type":1,"pageTitle":"Types Reference","url":"/docs/api/types#equalizerband","content":" interface EqualizerBand { band: number; gain: number; }   ","version":"Next","tagName":"h3"},{"title":"KaraokeOptions​","type":1,"pageTitle":"Types Reference","url":"/docs/api/types#karaokeoptions","content":" interface KaraokeOptions { level?: number; monoLevel?: number; filterBand?: number; filterWidth?: number; }   ","version":"Next","tagName":"h3"},{"title":"TimescaleOptions​","type":1,"pageTitle":"Types Reference","url":"/docs/api/types#timescaleoptions","content":" interface TimescaleOptions { speed?: number; pitch?: number; rate?: number; }   ","version":"Next","tagName":"h3"},{"title":"FrequencyDepthOptions​","type":1,"pageTitle":"Types Reference","url":"/docs/api/types#frequencydepthoptions","content":" interface FrequencyDepthOptions { frequency?: number; depth?: number; }   ","version":"Next","tagName":"h3"},{"title":"RotationOptions​","type":1,"pageTitle":"Types Reference","url":"/docs/api/types#rotationoptions","content":" interface RotationOptions { rotationHz?: number; }   ","version":"Next","tagName":"h3"},{"title":"DistortionOptions​","type":1,"pageTitle":"Types Reference","url":"/docs/api/types#distortionoptions","content":" interface DistortionOptions { sinOffset?: number; sinScale?: number; cosOffset?: number; cosScale?: number; tanOffset?: number; tanScale?: number; offset?: number; scale?: number; }   ","version":"Next","tagName":"h3"},{"title":"ChannelMixOptions​","type":1,"pageTitle":"Types Reference","url":"/docs/api/types#channelmixoptions","content":" interface ChannelMixOptions { leftToLeft?: number; leftToRight?: number; rightToLeft?: number; rightToRight?: number; }   ","version":"Next","tagName":"h3"},{"title":"LowPassOptions​","type":1,"pageTitle":"Types Reference","url":"/docs/api/types#lowpassoptions","content":" interface LowPassOptions { smoothing?: number; }   ","version":"Next","tagName":"h3"},{"title":"Track Related Types​","type":1,"pageTitle":"Types Reference","url":"/docs/api/types#track-related-types","content":" ","version":"Next","tagName":"h2"},{"title":"Track​","type":1,"pageTitle":"Types Reference","url":"/docs/api/types#track","content":" interface Track { encoded: string; info: TrackInfo; }   ","version":"Next","tagName":"h3"},{"title":"TrackInfo​","type":1,"pageTitle":"Types Reference","url":"/docs/api/types#trackinfo","content":" interface TrackInfo { identifier: string; isSeekable: boolean; author: string; length: number; isStream: boolean; position: number; title: string; uri?: string; artworkUrl?: string | null; sourceName?: string; requester?: string; }   ","version":"Next","tagName":"h3"},{"title":"LoadTrackResponse​","type":1,"pageTitle":"Types Reference","url":"/docs/api/types#loadtrackresponse","content":" interface LoadTrackResponse { loadType: string; data: Track[] | null; playlistInfo?: { name: string; selectedTrack?: number; }; exception?: { message: string; severity: string; }; }   ","version":"Next","tagName":"h3"},{"title":"Event Types​","type":1,"pageTitle":"Types Reference","url":"/docs/api/types#event-types","content":" ","version":"Next","tagName":"h2"},{"title":"LavalinkEvent​","type":1,"pageTitle":"Types Reference","url":"/docs/api/types#lavalinkevent","content":" interface LavalinkEvent { op: string; type?: string; guildId: string; [key: string]: any; }   ","version":"Next","tagName":"h3"},{"title":"NodeStats​","type":1,"pageTitle":"Types Reference","url":"/docs/api/types#nodestats","content":" interface NodeStats { players: number; playingPlayers: number; uptime: number; memory: { free: number; used: number; allocated: number; reservable: number; }; cpu: { cores: number; systemLoad: number; lavalinkLoad: number; }; frameStats?: { sent: number; nulled: number; deficit: number; }; }  ","version":"Next","tagName":"h3"},{"title":"Connectors","type":0,"sectionRef":"#","url":"/docs/api/connectors","content":"","keywords":"","version":"Next"},{"title":"Base Connector​","type":1,"pageTitle":"Connectors","url":"/docs/api/connectors#base-connector","content":" The Connector class is the base class for platform-specific implementations.  ","version":"Next","tagName":"h2"},{"title":"Properties​","type":1,"pageTitle":"Connectors","url":"/docs/api/connectors#properties","content":" abstract class Connector extends EventEmitter { public clientId: string; public nodes: Map&lt;string, Node&gt;; public voiceStates: Map&lt;string, any&gt;; public voiceServers: Map&lt;string, any&gt;; protected options: Required&lt;ConnectorOptions&gt;; }   ","version":"Next","tagName":"h3"},{"title":"Methods​","type":1,"pageTitle":"Connectors","url":"/docs/api/connectors#methods","content":" createNode(options: NodeOptions)​  Creates a new Lavalink node instance.  const node = connector.createNode({ name: 'main', url: 'localhost:2333', auth: 'password' });   destroyNode(node: Node)​  Destroys and removes a node instance.  connector.destroyNode(node);   createPlayer(options: PlayerOptions)​  Creates a new player instance.  const player = connector.createPlayer({ guildId: 'guild-id', voiceChannelId: 'channel-id' });   destroyPlayer(player: Player)​  Destroys and cleans up a player instance.  await connector.destroyPlayer(player);   loadTrack(query: string)​  Loads a track from a URL or search query.  const result = await connector.loadTrack('search query');   ","version":"Next","tagName":"h3"},{"title":"DiscordJSConnector​","type":1,"pageTitle":"Connectors","url":"/docs/api/connectors#discordjsconnector","content":" The DiscordJSConnector class implements the base Connector for Discord.js.  ","version":"Next","tagName":"h2"},{"title":"Constructor​","type":1,"pageTitle":"Connectors","url":"/docs/api/connectors#constructor","content":" import { Client } from 'discord.js'; import { DiscordJSConnector } from 'yukino'; const connector = new DiscordJSConnector({ client: client, auth: 'password', debug: true });   ","version":"Next","tagName":"h3"},{"title":"Voice State Management​","type":1,"pageTitle":"Connectors","url":"/docs/api/connectors#voice-state-management","content":" The connector automatically handles voice state and server updates from Discord:  // These are handled internally client.on('voiceStateUpdate', (oldState, newState) =&gt; { connector.handleVoiceStateUpdate(newState); }); client.on('voiceServerUpdate', (data) =&gt; { connector.handleVoiceServerUpdate(data); });   ","version":"Next","tagName":"h3"},{"title":"Voice Connection​","type":1,"pageTitle":"Connectors","url":"/docs/api/connectors#voice-connection","content":" sendVoiceUpdate(guildId: string, channelId: string | null, mute?: boolean, deaf?: boolean)​  Sends voice state updates to Discord.  // Join a voice channel await connector.sendVoiceUpdate('guild-id', 'channel-id', false, false); // Leave a voice channel await connector.sendVoiceUpdate('guild-id', null);   ","version":"Next","tagName":"h3"},{"title":"Creating Custom Connectors​","type":1,"pageTitle":"Connectors","url":"/docs/api/connectors#creating-custom-connectors","content":" You can create custom connectors for other Discord library implementations by extending the base Connector class:  import { Connector } from 'yukino'; class CustomConnector extends Connector { constructor(options: ConnectorOptions) { super(options); // Initialize your custom connector } public async sendVoiceUpdate( guildId: string, channelId: string | null, mute?: boolean, deaf?: boolean ): Promise&lt;void&gt; { // Implement voice state update logic for your library } }   ","version":"Next","tagName":"h2"},{"title":"Required Implementations​","type":1,"pageTitle":"Connectors","url":"/docs/api/connectors#required-implementations","content":" Custom connectors must implement:  Voice state update handlingVoice server update handlingClient ID managementVoice channel connection/disconnection  ","version":"Next","tagName":"h3"},{"title":"Example: Minimal Custom Connector​","type":1,"pageTitle":"Connectors","url":"/docs/api/connectors#example-minimal-custom-connector","content":" class MinimalConnector extends Connector { private client: any; // Your client type constructor(options: ConnectorOptions) { super(options); this.client = options.client; // Set up event listeners this.client.on('voiceStateUpdate', this.onVoiceStateUpdate.bind(this)); this.client.on('voiceServerUpdate', this.onVoiceServerUpdate.bind(this)); } private onVoiceStateUpdate(data: any): void { this.voiceStates.set(data.guild_id, { sessionId: data.session_id, channelId: data.channel_id, userId: data.user_id }); this.updateVoiceState(data.guild_id); } private onVoiceServerUpdate(data: any): void { this.voiceServers.set(data.guild_id, { token: data.token, endpoint: data.endpoint }); this.updateVoiceState(data.guild_id); } private updateVoiceState(guildId: string): void { const state = this.voiceStates.get(guildId); const server = this.voiceServers.get(guildId); if (state &amp;&amp; server) { // Update the node with new voice state const node = this.nodes.values().next().value; if (node) { node.updateVoiceState(guildId, state, server); } } } public async sendVoiceUpdate( guildId: string, channelId: string | null, mute = false, deaf = false ): Promise&lt;void&gt; { await this.client.updateVoiceState({ guild_id: guildId, channel_id: channelId, self_mute: mute, self_deaf: deaf }); } }   ","version":"Next","tagName":"h3"},{"title":"Best Practices​","type":1,"pageTitle":"Connectors","url":"/docs/api/connectors#best-practices","content":" Handle voice state cleanup:  class BetterConnector extends Connector { public destroy(): void { this.voiceStates.clear(); this.voiceServers.clear(); this.nodes.clear(); } }   Implement error handling:  class RobustConnector extends Connector { public async sendVoiceUpdate(...args): Promise&lt;void&gt; { try { await super.sendVoiceUpdate(...args); } catch (error) { this.emit('error', error); throw error; } } }   Add debug logging:  class DebugConnector extends Connector { private logger: Logger; constructor(options: ConnectorOptions) { super(options); this.logger = Logger.create('Connector', options.debug || false); } protected onVoiceStateUpdate(data: any): void { this.logger.debug('Voice state update:', data); super.onVoiceStateUpdate(data); } }  ","version":"Next","tagName":"h2"},{"title":"Audio Filters","type":0,"sectionRef":"#","url":"/docs/features/filters","content":"","keywords":"","version":"Next"},{"title":"Equalizer​","type":1,"pageTitle":"Audio Filters","url":"/docs/features/filters#equalizer","content":" The equalizer allows you to adjust the gain of 15 different frequency bands:  // Each band represents a frequency range: // Band 0: 25Hz Band 8: 1000Hz // Band 1: 40Hz Band 9: 1600Hz // Band 2: 63Hz Band 10: 2500Hz // Band 3: 100Hz Band 11: 4000Hz // Band 4: 160Hz Band 12: 6300Hz // Band 5: 250Hz Band 13: 10000Hz // Band 6: 400Hz Band 14: 16000Hz // Band 7: 630Hz await player.setEqualizer([ { band: 0, gain: 0.6 }, // Boost bass { band: 1, gain: 0.7 }, { band: 2, gain: 0.8 }, { band: 3, gain: 0.5 } ]);   ","version":"Next","tagName":"h2"},{"title":"Preset Equalizers​","type":1,"pageTitle":"Audio Filters","url":"/docs/features/filters#preset-equalizers","content":" Yukino provides some preset equalizers through the FilterUtil:  import { FilterUtil } from 'yukino'; // Bass boost preset const bassBoostEQ = FilterUtil.createBassBoostEQ(0.5); await player.setEqualizer(bassBoostEQ); // Flat equalizer (reset) const flatEQ = FilterUtil.createFlatEQ(); await player.setEqualizer(flatEQ);   ","version":"Next","tagName":"h3"},{"title":"Karaoke​","type":1,"pageTitle":"Audio Filters","url":"/docs/features/filters#karaoke","content":" The karaoke filter can remove vocals from tracks:  await player.setKaraoke({ level: 1.0, // Main karaoke level monoLevel: 1.0, // Mono channel level filterBand: 220.0, // Band to filter (Hz) filterWidth: 100.0 // Filter width }); // Remove karaoke filter await player.clearKaraoke();   ","version":"Next","tagName":"h2"},{"title":"Timescale​","type":1,"pageTitle":"Audio Filters","url":"/docs/features/filters#timescale","content":" Modify the speed, pitch, and rate of the audio:  await player.setTimescale({ speed: 1.2, // Change playback speed pitch: 1.2, // Change pitch rate: 1.0 // Change sampling rate }); // Nightcore preset await player.setFilters(FilterUtil.nightcorePreset()); // Vaporwave preset await player.setFilters(FilterUtil.vaporwavePreset()); // Remove timescale await player.clearTimescale();   ","version":"Next","tagName":"h2"},{"title":"Tremolo​","type":1,"pageTitle":"Audio Filters","url":"/docs/features/filters#tremolo","content":" Add a wavering effect to the audio:  await player.setTremolo({ frequency: 2.0, // How fast the volume changes depth: 0.5 // How much the volume changes }); // Remove tremolo await player.clearTremolo();   ","version":"Next","tagName":"h2"},{"title":"Vibrato​","type":1,"pageTitle":"Audio Filters","url":"/docs/features/filters#vibrato","content":" Add a vibrating pitch effect:  await player.setVibrato({ frequency: 2.0, // How fast the pitch changes depth: 0.5 // How much the pitch changes }); // Remove vibrato await player.clearVibrato();   ","version":"Next","tagName":"h2"},{"title":"Rotation​","type":1,"pageTitle":"Audio Filters","url":"/docs/features/filters#rotation","content":" Create a rotating audio effect:  await player.setRotation({ rotationHz: 0.2 // Rotation speed in Hz }); // 8D Audio preset await player.setFilters(FilterUtil.eightDimensionalPreset()); // Remove rotation await player.clearRotation();   ","version":"Next","tagName":"h2"},{"title":"Channel Mix​","type":1,"pageTitle":"Audio Filters","url":"/docs/features/filters#channel-mix","content":" Control the mixing of stereo channels:  await player.setChannelMix({ leftToLeft: 1.0, // Left channel to left output leftToRight: 0.0, // Left channel to right output rightToLeft: 0.0, // Right channel to left output rightToRight: 1.0 // Right channel to right output }); // Remove channel mix await player.clearChannelMix();   ","version":"Next","tagName":"h2"},{"title":"Low Pass​","type":1,"pageTitle":"Audio Filters","url":"/docs/features/filters#low-pass","content":" Apply a low pass filter to remove high frequencies:  await player.setLowPass({ smoothing: 20.0 // Smoothing factor }); // Remove low pass await player.clearLowPass();   ","version":"Next","tagName":"h2"},{"title":"Combining Filters​","type":1,"pageTitle":"Audio Filters","url":"/docs/features/filters#combining-filters","content":" You can apply multiple filters at once using setFilters:  await player.setFilters({ equalizer: [ { band: 0, gain: 0.6 }, { band: 1, gain: 0.7 } ], timescale: { speed: 1.2, pitch: 1.2 }, tremolo: { frequency: 2.0, depth: 0.5 } }); // Clear all filters await player.clearFilters();   ","version":"Next","tagName":"h2"},{"title":"Best Practices​","type":1,"pageTitle":"Audio Filters","url":"/docs/features/filters#best-practices","content":" Reset filters when changing tracks:  player.on('trackStart', async () =&gt; { await player.clearFilters(); });   Avoid extreme filter values:  // Good await player.setTimescale({ speed: 1.5 }); // Bad - might cause distortion await player.setTimescale({ speed: 5.0 });   Consider performance impact:  // Apply filters gradually const filters = []; for (let i = 0; i &lt; 15; i++) { filters.push({ band: i, gain: 0.1 }); await player.setEqualizer(filters); await new Promise(r =&gt; setTimeout(r, 50)); }  ","version":"Next","tagName":"h2"},{"title":"Effects","type":0,"sectionRef":"#","url":"/docs/features/effects","content":"","keywords":"","version":"Next"},{"title":"Basic Usage​","type":1,"pageTitle":"Effects","url":"/docs/features/effects#basic-usage","content":" ","version":"Next","tagName":"h2"},{"title":"Applying Effects​","type":1,"pageTitle":"Effects","url":"/docs/features/effects#applying-effects","content":" // Apply a single effect player.effects.apply('bassboost'); // Apply multiple effects player.effects.applyMany(['nightcore', 'echo']); // Apply with custom parameters player.effects.apply('tremolo', { frequency: 2.0, depth: 0.5 });   ","version":"Next","tagName":"h3"},{"title":"Removing Effects​","type":1,"pageTitle":"Effects","url":"/docs/features/effects#removing-effects","content":" // Remove a single effect player.effects.remove('bassboost'); // Remove multiple effects player.effects.removeMany(['nightcore', 'echo']); // Clear all effects player.effects.clear();   ","version":"Next","tagName":"h3"},{"title":"Built-in Effects​","type":1,"pageTitle":"Effects","url":"/docs/features/effects#built-in-effects","content":" ","version":"Next","tagName":"h2"},{"title":"Bass Boost​","type":1,"pageTitle":"Effects","url":"/docs/features/effects#bass-boost","content":" // Default bass boost player.effects.apply('bassboost'); // Custom bass boost levels player.effects.apply('bassboost', { level: 0.5, // 0.0 to 1.0 frequency: 100 // Bass frequency to boost });   ","version":"Next","tagName":"h3"},{"title":"Nightcore​","type":1,"pageTitle":"Effects","url":"/docs/features/effects#nightcore","content":" // Default nightcore player.effects.apply('nightcore'); // Custom nightcore settings player.effects.apply('nightcore', { pitch: 1.3, // Pitch multiplier speed: 1.2 // Speed multiplier });   ","version":"Next","tagName":"h3"},{"title":"Vaporwave​","type":1,"pageTitle":"Effects","url":"/docs/features/effects#vaporwave","content":" // Default vaporwave player.effects.apply('vaporwave'); // Custom vaporwave settings player.effects.apply('vaporwave', { pitch: 0.8, // Pitch multiplier speed: 0.8 // Speed multiplier });   ","version":"Next","tagName":"h3"},{"title":"Echo​","type":1,"pageTitle":"Effects","url":"/docs/features/effects#echo","content":" // Default echo player.effects.apply('echo'); // Custom echo settings player.effects.apply('echo', { delay: 0.5, // Delay in seconds decay: 0.5, // Echo decay feedback: 0.75 // Echo feedback });   ","version":"Next","tagName":"h3"},{"title":"Tremolo​","type":1,"pageTitle":"Effects","url":"/docs/features/effects#tremolo","content":" // Default tremolo player.effects.apply('tremolo'); // Custom tremolo settings player.effects.apply('tremolo', { frequency: 4.0, // Oscillation frequency depth: 0.5 // Effect depth });   ","version":"Next","tagName":"h3"},{"title":"Vibrato​","type":1,"pageTitle":"Effects","url":"/docs/features/effects#vibrato","content":" // Default vibrato player.effects.apply('vibrato'); // Custom vibrato settings player.effects.apply('vibrato', { frequency: 2.0, // Oscillation frequency depth: 0.5 // Effect depth });   ","version":"Next","tagName":"h3"},{"title":"Effect Chains​","type":1,"pageTitle":"Effects","url":"/docs/features/effects#effect-chains","content":" ","version":"Next","tagName":"h2"},{"title":"Creating Effect Chains​","type":1,"pageTitle":"Effects","url":"/docs/features/effects#creating-effect-chains","content":" // Create a chain of effects player.effects.chain() .add('bassboost', { level: 0.6 }) .add('echo', { delay: 0.3 }) .add('tremolo') .apply(); // Create and save a chain const chain = player.effects.chain() .add('nightcore') .add('echo'); // Apply saved chain later chain.apply();   ","version":"Next","tagName":"h3"},{"title":"Managing Chains​","type":1,"pageTitle":"Effects","url":"/docs/features/effects#managing-chains","content":" // Remove specific effect from chain chain.remove('echo'); // Clear chain chain.clear(); // Check chain contents console.log(chain.effects);   ","version":"Next","tagName":"h3"},{"title":"Custom Effects​","type":1,"pageTitle":"Effects","url":"/docs/features/effects#custom-effects","content":" ","version":"Next","tagName":"h2"},{"title":"Creating Custom Effects​","type":1,"pageTitle":"Effects","url":"/docs/features/effects#creating-custom-effects","content":" // Define custom effect const customEffect = { name: 'customBoost', parameters: { frequency: 150, gain: 0.5 }, apply: (player, params) =&gt; { // Implementation player.setEqualizerBand(0, params.gain); } }; // Register custom effect player.effects.register(customEffect); // Use custom effect player.effects.apply('customBoost', { frequency: 200, gain: 0.7 });   ","version":"Next","tagName":"h3"},{"title":"Effect Presets​","type":1,"pageTitle":"Effects","url":"/docs/features/effects#effect-presets","content":" // Create effect preset const preset = { name: 'party', effects: [ ['bassboost', { level: 0.7 }], ['tremolo', { frequency: 3.0 }], ['echo', { delay: 0.2 }] ] }; // Register preset player.effects.registerPreset(preset); // Apply preset player.effects.applyPreset('party');   ","version":"Next","tagName":"h3"},{"title":"Real-time Control​","type":1,"pageTitle":"Effects","url":"/docs/features/effects#real-time-control","content":" ","version":"Next","tagName":"h2"},{"title":"Dynamic Parameters​","type":1,"pageTitle":"Effects","url":"/docs/features/effects#dynamic-parameters","content":" // Update effect parameters in real-time player.effects.update('tremolo', { frequency: 5.0, depth: 0.8 }); // Smoothly transition parameters player.effects.transition('tremolo', { frequency: 6.0, depth: 0.9 }, 2000); // Duration in ms   ","version":"Next","tagName":"h3"},{"title":"Effect States​","type":1,"pageTitle":"Effects","url":"/docs/features/effects#effect-states","content":" // Check if effect is active console.log(player.effects.isActive('bassboost')); // Get active effects console.log(player.effects.active); // Get effect parameters const params = player.effects.getParameters('echo');   ","version":"Next","tagName":"h3"},{"title":"Performance Considerations​","type":1,"pageTitle":"Effects","url":"/docs/features/effects#performance-considerations","content":" ","version":"Next","tagName":"h2"},{"title":"Memory Usage​","type":1,"pageTitle":"Effects","url":"/docs/features/effects#memory-usage","content":" // Clear unused effects player.effects.cleanup(); // Optimize chain processing player.effects.optimize();   ","version":"Next","tagName":"h3"},{"title":"CPU Usage​","type":1,"pageTitle":"Effects","url":"/docs/features/effects#cpu-usage","content":" // Get effect CPU usage const usage = player.effects.getUsage(); // Set processing limits player.effects.setLimit({ maxEffects: 5, maxChainLength: 3 });   ","version":"Next","tagName":"h3"},{"title":"Events​","type":1,"pageTitle":"Effects","url":"/docs/features/effects#events","content":" ","version":"Next","tagName":"h2"},{"title":"Effect Events​","type":1,"pageTitle":"Effects","url":"/docs/features/effects#effect-events","content":" // Effect applied player.effects.on('effectApply', (effect, params) =&gt; { console.log(`Applied ${effect} with:`, params); }); // Effect removed player.effects.on('effectRemove', (effect) =&gt; { console.log(`Removed ${effect}`); }); // Parameters updated player.effects.on('effectUpdate', (effect, params) =&gt; { console.log(`Updated ${effect} with:`, params); });   ","version":"Next","tagName":"h3"},{"title":"Error Handling​","type":1,"pageTitle":"Effects","url":"/docs/features/effects#error-handling","content":" // Handle effect errors player.effects.on('error', (error, effect) =&gt; { console.error(`Error in ${effect}:`, error); }); // Validate effect parameters try { player.effects.validate('tremolo', params); } catch (error) { console.error('Invalid parameters:', error); }  ","version":"Next","tagName":"h3"},{"title":"Client","type":0,"sectionRef":"#","url":"/docs/core/client","content":"","keywords":"","version":"Next"},{"title":"Creating a Client​","type":1,"pageTitle":"Client","url":"/docs/core/client#creating-a-client","content":" import { Client } from 'discord.js'; import { YukinoClient } from 'yukino'; const yukino = new YukinoClient(client, { auth: 'your-password', debug: true, // Custom options reconnectInterval: 5000, reconnectTries: 3 });   ","version":"Next","tagName":"h2"},{"title":"Configuration Options​","type":1,"pageTitle":"Client","url":"/docs/core/client#configuration-options","content":" ","version":"Next","tagName":"h2"},{"title":"Required Options​","type":1,"pageTitle":"Client","url":"/docs/core/client#required-options","content":" auth - The password for your Lavalink serverclient - Your Discord.js client instance  ","version":"Next","tagName":"h3"},{"title":"Optional Options​","type":1,"pageTitle":"Client","url":"/docs/core/client#optional-options","content":" debug - Enable debug logging (default: false)reconnectInterval - Time between reconnect attempts in ms (default: 5000)reconnectTries - Number of reconnect attempts (default: 3)defaultSearchPlatform - Platform to search on when no source is specified (default: 'youtube')userAgent - Custom user agent for REST requests  ","version":"Next","tagName":"h3"},{"title":"Node Management​","type":1,"pageTitle":"Client","url":"/docs/core/client#node-management","content":" ","version":"Next","tagName":"h2"},{"title":"Adding Nodes​","type":1,"pageTitle":"Client","url":"/docs/core/client#adding-nodes","content":" // Add a single node yukino.addNode({ name: 'main', url: 'localhost:2333', auth: 'your-password', secure: false }); // Add multiple nodes yukino.addNodes([ { name: 'node1', url: 'node1.example.com:2333', auth: 'password1', secure: true }, { name: 'node2', url: 'node2.example.com:2333', auth: 'password2', secure: true } ]);   ","version":"Next","tagName":"h3"},{"title":"Node Selection​","type":1,"pageTitle":"Client","url":"/docs/core/client#node-selection","content":" Yukino automatically selects the best node for each player based on:  Load balancingNode statusNode penalty (calculated from CPU/memory usage)  You can customize node selection:  yukino.setNodeSelector((nodes, guildId) =&gt; { // Custom node selection logic return nodes.sort((a, b) =&gt; (a.stats.cpu / a.stats.memory) - (b.stats.cpu / b.stats.memory) )[0]; });   ","version":"Next","tagName":"h3"},{"title":"Player Management​","type":1,"pageTitle":"Client","url":"/docs/core/client#player-management","content":" ","version":"Next","tagName":"h2"},{"title":"Creating Players​","type":1,"pageTitle":"Client","url":"/docs/core/client#creating-players","content":" const player = await yukino.createPlayer({ guildId: 'guild-id', voiceChannelId: 'channel-id', textChannelId: 'text-channel-id', // Optional deaf: true, // Whether to deafen the bot mute: false // Whether to mute the bot });   ","version":"Next","tagName":"h3"},{"title":"Getting Players​","type":1,"pageTitle":"Client","url":"/docs/core/client#getting-players","content":" // Get a specific player const player = yukino.getPlayer('guild-id'); // Get all players const players = yukino.players; // Check if a guild has a player const hasPlayer = yukino.hasPlayer('guild-id');   ","version":"Next","tagName":"h3"},{"title":"Destroying Players​","type":1,"pageTitle":"Client","url":"/docs/core/client#destroying-players","content":" // Destroy a specific player await yukino.destroyPlayer('guild-id'); // Destroy all players await yukino.destroyAllPlayers();   ","version":"Next","tagName":"h3"},{"title":"Track Loading​","type":1,"pageTitle":"Client","url":"/docs/core/client#track-loading","content":" ","version":"Next","tagName":"h2"},{"title":"Loading Tracks​","type":1,"pageTitle":"Client","url":"/docs/core/client#loading-tracks","content":" // Load a track by search query const result = await yukino.loadTrack('never gonna give you up'); // Load a track by URL const result = await yukino.loadTrack('https://youtube.com/watch?v=dQw4w9WgXcQ'); // Load a playlist const result = await yukino.loadTrack('https://youtube.com/playlist?list=...');   ","version":"Next","tagName":"h3"},{"title":"Search Options​","type":1,"pageTitle":"Client","url":"/docs/core/client#search-options","content":" const result = await yukino.loadTrack('your query', { // Specify search source source: 'youtube', // 'youtube', 'soundcloud', etc. // Add additional context context: { requester: 'user-id', guild: 'guild-id' } });   ","version":"Next","tagName":"h3"},{"title":"Event Handling​","type":1,"pageTitle":"Client","url":"/docs/core/client#event-handling","content":" ","version":"Next","tagName":"h2"},{"title":"Node Events​","type":1,"pageTitle":"Client","url":"/docs/core/client#node-events","content":" // Node connected yukino.node.on('nodeConnect', (node) =&gt; { console.log(`Node ${node.name} connected`); }); // Node disconnected yukino.node.on('nodeDisconnect', (node, reason) =&gt; { console.log(`Node ${node.name} disconnected:`, reason); }); // Node error yukino.node.on('nodeError', (node, error) =&gt; { console.error(`Node ${node.name} error:`, error); });   ","version":"Next","tagName":"h3"},{"title":"Track Events​","type":1,"pageTitle":"Client","url":"/docs/core/client#track-events","content":" // Track started yukino.node.on('trackStart', (player, track) =&gt; { console.log(`Playing ${track.info.title}`); }); // Track ended yukino.node.on('trackEnd', (player, track) =&gt; { console.log(`Finished ${track.info.title}`); }); // Track stuck yukino.node.on('trackStuck', (player, track, thresholdMs) =&gt; { console.warn(`Track ${track.info.title} stuck for ${thresholdMs}ms`); }); // Track error yukino.node.on('trackError', (player, track, error) =&gt; { console.error(`Error playing ${track.info.title}:`, error); });   ","version":"Next","tagName":"h3"},{"title":"Voice Events​","type":1,"pageTitle":"Client","url":"/docs/core/client#voice-events","content":" // Voice state update yukino.node.on('voiceStateUpdate', (state) =&gt; { console.log('Voice state updated:', state); }); // Voice server update yukino.node.on('voiceServerUpdate', (server) =&gt; { console.log('Voice server updated:', server); });   ","version":"Next","tagName":"h3"},{"title":"Error Handling​","type":1,"pageTitle":"Client","url":"/docs/core/client#error-handling","content":" ","version":"Next","tagName":"h2"},{"title":"Client Level Error Handling​","type":1,"pageTitle":"Client","url":"/docs/core/client#client-level-error-handling","content":" yukino.on('error', (error) =&gt; { console.error('Client error:', error); }); yukino.on('warn', (warning) =&gt; { console.warn('Client warning:', warning); }); // Handle specific errors yukino.on('nodeError', (node, error) =&gt; { if (error.code === 'ECONNREFUSED') { console.error(`Failed to connect to node ${node.name}`); } });   ","version":"Next","tagName":"h3"},{"title":"Player Level Error Handling​","type":1,"pageTitle":"Client","url":"/docs/core/client#player-level-error-handling","content":" const player = await yukino.createPlayer({ guildId: 'guild-id', voiceChannelId: 'channel-id' }); player.on('error', (error) =&gt; { console.error('Player error:', error); }); // Handle track errors player.on('trackError', (track, error) =&gt; { console.error(`Error playing ${track.info.title}:`, error); // Skip to next track player.skip().catch(console.error); });   ","version":"Next","tagName":"h3"},{"title":"Advanced Usage​","type":1,"pageTitle":"Client","url":"/docs/core/client#advanced-usage","content":" ","version":"Next","tagName":"h2"},{"title":"Custom REST Options​","type":1,"pageTitle":"Client","url":"/docs/core/client#custom-rest-options","content":" const yukino = new YukinoClient(client, { auth: 'your-password', rest: { timeout: 10000, retries: 3, headers: { 'User-Agent': 'MyBot/1.0.0' } } });   ","version":"Next","tagName":"h3"},{"title":"Node Groups​","type":1,"pageTitle":"Client","url":"/docs/core/client#node-groups","content":" // Create node groups for different regions yukino.addNodes([ { name: 'us-east', url: 'us1.example.com:2333', group: 'us' }, { name: 'us-west', url: 'us2.example.com:2333', group: 'us' }, { name: 'eu-central', url: 'eu1.example.com:2333', group: 'eu' } ]); // Select nodes by group yukino.setNodeSelector((nodes, guildId) =&gt; { const guild = client.guilds.cache.get(guildId); const region = guild.preferredLocale.includes('en-US') ? 'us' : 'eu'; return nodes .filter(node =&gt; node.group === region) .sort((a, b) =&gt; a.penalties - b.penalties)[0]; });   ","version":"Next","tagName":"h3"},{"title":"State Management​","type":1,"pageTitle":"Client","url":"/docs/core/client#state-management","content":" // Get client state console.log('Version:', yukino.version); console.log('Connected:', yukino.isReady); console.log('Total players:', yukino.players.size); console.log('Total nodes:', yukino.nodes.size); // Get detailed stats const stats = yukino.getLavaStats(); console.log('Players:', stats.players); console.log('Playing players:', stats.playingPlayers); console.log('Uptime:', stats.uptime); console.log('Memory usage:', stats.memory); console.log('CPU usage:', stats.cpu);  ","version":"Next","tagName":"h3"},{"title":"Custom Filters","type":0,"sectionRef":"#","url":"/docs/advanced/custom-filters","content":"","keywords":"","version":"Next"},{"title":"Creating Custom Filter Combinations​","type":1,"pageTitle":"Custom Filters","url":"/docs/advanced/custom-filters#creating-custom-filter-combinations","content":" You can combine multiple filters to create unique audio effects:  interface CustomFilter { name: string; filters: FilterOptions; } class CustomFilterManager { private filters: Map&lt;string, CustomFilter&gt;; constructor() { this.filters = new Map(); } addFilter(name: string, filters: FilterOptions) { this.filters.set(name, { name, filters }); } async applyFilter(player: Player, name: string) { const filter = this.filters.get(name); if (!filter) throw new Error(`Filter &quot;${name}&quot; not found`); await player.setFilters(filter.filters); } }   ","version":"Next","tagName":"h2"},{"title":"Example Custom Filters​","type":1,"pageTitle":"Custom Filters","url":"/docs/advanced/custom-filters#example-custom-filters","content":" Night Mode Filter​  const filterManager = new CustomFilterManager(); filterManager.addFilter('night-mode', { equalizer: [ { band: 0, gain: 0.3 }, { band: 1, gain: 0.3 }, { band: 2, gain: 0.2 }, { band: 3, gain: 0.1 }, { band: 4, gain: -0.1 }, { band: 5, gain: -0.2 }, { band: 6, gain: -0.3 }, { band: 7, gain: -0.3 }, { band: 8, gain: -0.3 }, { band: 9, gain: -0.3 }, { band: 10, gain: -0.2 }, { band: 11, gain: -0.2 }, { band: 12, gain: -0.2 }, { band: 13, gain: -0.1 } ], lowPass: { smoothing: 15.0 } });   Enhanced Vocals Filter​  filterManager.addFilter('enhanced-vocals', { equalizer: [ { band: 0, gain: -0.2 }, { band: 1, gain: -0.2 }, { band: 2, gain: -0.1 }, { band: 3, gain: 0.0 }, { band: 4, gain: 0.3 }, { band: 5, gain: 0.4 }, { band: 6, gain: 0.4 }, { band: 7, gain: 0.3 }, { band: 8, gain: 0.0 }, { band: 9, gain: -0.1 }, { band: 10, gain: -0.2 }, { band: 11, gain: -0.2 }, { band: 12, gain: -0.3 }, { band: 13, gain: -0.3 } ] });   ","version":"Next","tagName":"h3"},{"title":"Filter Interpolation​","type":1,"pageTitle":"Custom Filters","url":"/docs/advanced/custom-filters#filter-interpolation","content":" Create smooth transitions between filters:  interface InterpolationOptions { steps?: number; duration?: number; } async function interpolateFilters( player: Player, targetFilters: FilterOptions, options: InterpolationOptions = {} ) { const { steps = 10, duration = 500 } = options; const stepDuration = duration / steps; const currentFilters = player.filters; for (let i = 1; i &lt;= steps; i++) { const fraction = i / steps; const interpolated = interpolateFilterValues( currentFilters, targetFilters, fraction ); await player.setFilters(interpolated); await new Promise(r =&gt; setTimeout(r, stepDuration)); } } function interpolateFilterValues( current: FilterOptions, target: FilterOptions, fraction: number ): FilterOptions { const result: FilterOptions = {}; // Interpolate volume if (target.volume !== undefined) { result.volume = lerp( current.volume ?? 100, target.volume, fraction ); } // Interpolate equalizer if (target.equalizer) { result.equalizer = target.equalizer.map((band, i) =&gt; ({ band: band.band, gain: lerp( current.equalizer?.[i]?.gain ?? 0, band.gain, fraction ) })); } // Interpolate other filters... return result; } function lerp(start: number, end: number, fraction: number): number { return start + (end - start) * fraction; }   ","version":"Next","tagName":"h2"},{"title":"Dynamic Filter Generation​","type":1,"pageTitle":"Custom Filters","url":"/docs/advanced/custom-filters#dynamic-filter-generation","content":" Create filters based on audio analysis:  async function createDynamicEqualizer( player: Player, analysis: TrackAnalysis ): Promise&lt;EqualizerBand[]&gt; { const bands: EqualizerBand[] = []; // Example: Boost frequencies where vocals are typically present if (analysis.hasVocals) { bands.push( { band: 4, gain: 0.3 }, // 160Hz { band: 5, gain: 0.4 }, // 250Hz { band: 6, gain: 0.4 } // 400Hz ); } // Example: Reduce bass for electronic music if (analysis.genre === 'electronic') { bands.push( { band: 0, gain: -0.2 }, // 25Hz { band: 1, gain: -0.1 } // 40Hz ); } return bands; }   ","version":"Next","tagName":"h2"},{"title":"Advanced Filter Management​","type":1,"pageTitle":"Custom Filters","url":"/docs/advanced/custom-filters#advanced-filter-management","content":" ","version":"Next","tagName":"h2"},{"title":"Filter Chain System​","type":1,"pageTitle":"Custom Filters","url":"/docs/advanced/custom-filters#filter-chain-system","content":" class FilterChain { private filters: FilterOptions[] = []; add(filter: FilterOptions) { this.filters.push(filter); return this; } async apply(player: Player) { const combined = this.filters.reduce( (acc, filter) =&gt; this.combineFilters(acc, filter), {} as FilterOptions ); await player.setFilters(combined); } private combineFilters( a: FilterOptions, b: FilterOptions ): FilterOptions { return { ...a, ...b, equalizer: this.combineEqualizers( a.equalizer || [], b.equalizer || [] ) }; } private combineEqualizers( a: EqualizerBand[], b: EqualizerBand[] ): EqualizerBand[] { return Array(15).fill(0).map((_, i) =&gt; ({ band: i, gain: (a.find(x =&gt; x.band === i)?.gain || 0) + (b.find(x =&gt; x.band === i)?.gain || 0) })); } }   ","version":"Next","tagName":"h3"},{"title":"Best Practices​","type":1,"pageTitle":"Custom Filters","url":"/docs/advanced/custom-filters#best-practices","content":" Validate filter values:  function validateFilters(filters: FilterOptions): void { if (filters.volume !== undefined) { if (filters.volume &lt; 0 || filters.volume &gt; 1000) { throw new Error('Volume must be between 0 and 1000'); } } if (filters.equalizer) { for (const band of filters.equalizer) { if (band.gain &lt; -0.25 || band.gain &gt; 1.0) { throw new Error('Equalizer gain must be between -0.25 and 1.0'); } } } // Validate other filters... }   Cache filter combinations:  class CachedFilterManager { private cache = new Map&lt;string, FilterOptions&gt;(); getFilter(name: string, generate: () =&gt; FilterOptions): FilterOptions { if (!this.cache.has(name)) { this.cache.set(name, generate()); } return this.cache.get(name)!; } }   Handle performance:  // Limit filter updates let lastUpdate = 0; const UPDATE_INTERVAL = 50; // ms async function updateFilters(player: Player, filters: FilterOptions) { const now = Date.now(); if (now - lastUpdate &lt; UPDATE_INTERVAL) { return; } lastUpdate = now; await player.setFilters(filters); }  ","version":"Next","tagName":"h2"},{"title":"Voice State Management","type":0,"sectionRef":"#","url":"/docs/advanced/voice-state","content":"","keywords":"","version":"Next"},{"title":"Understanding Voice State Flow​","type":1,"pageTitle":"Voice State Management","url":"/docs/advanced/voice-state#understanding-voice-state-flow","content":" // Voice state flow: // 1. Discord.js emits voice state/server updates // 2. Connector receives and processes updates // 3. Node handles voice connection // 4. Player manages voice state   ","version":"Next","tagName":"h2"},{"title":"Handling Voice Events​","type":1,"pageTitle":"Voice State Management","url":"/docs/advanced/voice-state#handling-voice-events","content":" yukino.node.on('voiceStateUpdate', (state) =&gt; { console.log('Voice state update:', { guildId: state.guild_id, channelId: state.channel_id, sessionId: state.session_id }); }); yukino.node.on('voiceServerUpdate', (server) =&gt; { console.log('Voice server update:', { guildId: server.guild_id, endpoint: server.endpoint }); }); yukino.node.on('voiceConnected', (player) =&gt; { console.log(`Connected to voice in guild ${player.guildId}`); }); yukino.node.on('voiceDisconnected', (player) =&gt; { console.log(`Disconnected from voice in guild ${player.guildId}`); });   ","version":"Next","tagName":"h2"},{"title":"Custom Voice State Handler​","type":1,"pageTitle":"Voice State Management","url":"/docs/advanced/voice-state#custom-voice-state-handler","content":" Create a handler to manage voice state:  class VoiceStateHandler { private players: Map&lt;string, Player&gt;; private reconnectTimeouts: Map&lt;string, NodeJS.Timeout&gt;; constructor(private yukino: YukinoClient) { this.players = new Map(); this.reconnectTimeouts = new Map(); this.setupEventListeners(); } private setupEventListeners() { this.yukino.node.on('voiceStateUpdate', this.handleVoiceState.bind(this)); this.yukino.node.on('voiceServerUpdate', this.handleVoiceServer.bind(this)); this.yukino.node.on('voiceDisconnected', this.handleDisconnect.bind(this)); } private async handleVoiceState(state: any) { const player = this.yukino.getPlayer(state.guild_id); if (!player) return; // Handle bot being moved to different channel if (state.channel_id &amp;&amp; state.channel_id !== player.voiceChannelId) { player.voiceChannelId = state.channel_id; // Optionally pause playback await player.pause(true); } // Handle bot being disconnected if (!state.channel_id) { this.scheduleReconnect(state.guild_id); } } private handleVoiceServer(server: any) { const player = this.yukino.getPlayer(server.guild_id); if (!player) return; // Clear any pending reconnect this.clearReconnectTimeout(server.guild_id); } private handleDisconnect(player: Player) { this.scheduleReconnect(player.guildId); } private scheduleReconnect(guildId: string, attempt = 1) { this.clearReconnectTimeout(guildId); if (attempt &gt; 5) { console.error(`Failed to reconnect after 5 attempts in guild ${guildId}`); return; } const timeout = setTimeout(async () =&gt; { const player = this.yukino.getPlayer(guildId); if (!player) return; try { await player.connect(); } catch (error) { console.error('Reconnect failed:', error); this.scheduleReconnect(guildId, attempt + 1); } }, Math.min(1000 * attempt, 5000)); this.reconnectTimeouts.set(guildId, timeout); } private clearReconnectTimeout(guildId: string) { const timeout = this.reconnectTimeouts.get(guildId); if (timeout) { clearTimeout(timeout); this.reconnectTimeouts.delete(guildId); } } // Handle cleanup public destroy() { for (const timeout of this.reconnectTimeouts.values()) { clearTimeout(timeout); } this.reconnectTimeouts.clear(); } }   ","version":"Next","tagName":"h2"},{"title":"Automatic Voice Channel Management​","type":1,"pageTitle":"Voice State Management","url":"/docs/advanced/voice-state#automatic-voice-channel-management","content":" Handle users joining/leaving voice channels:  class VoiceChannelManager { private leaveTimeouts: Map&lt;string, NodeJS.Timeout&gt;; constructor(private yukino: YukinoClient) { this.leaveTimeouts = new Map(); this.setupEventListeners(); } private setupEventListeners() { this.yukino.connector.client.on('voiceStateUpdate', async (oldState, newState) =&gt; { const player = this.yukino.getPlayer(oldState.guild.id); if (!player) return; // Handle user leaving the bot's channel if (oldState.channelId === player.voiceChannelId &amp;&amp; newState.channelId !== player.voiceChannelId) { this.handleUserLeave(player); } // Handle user joining the bot's channel if (newState.channelId === player.voiceChannelId) { this.handleUserJoin(player); } }); } private handleUserLeave(player: Player) { const channel = this.yukino.connector.client.channels.cache.get( player.voiceChannelId ) as VoiceChannel; // Count members in voice channel (excluding the bot) const members = channel.members.size - 1; if (members === 0) { // Schedule disconnect if no users remain const timeout = setTimeout(() =&gt; { if (player.playing) player.pause(true); player.disconnect(); }, 5 * 60 * 1000); // 5 minutes this.leaveTimeouts.set(player.guildId, timeout); } } private handleUserJoin(player: Player) { // Clear leave timeout when users join const timeout = this.leaveTimeouts.get(player.guildId); if (timeout) { clearTimeout(timeout); this.leaveTimeouts.delete(player.guildId); // Resume playback if it was paused if (player.paused) player.pause(false); } } public destroy() { for (const timeout of this.leaveTimeouts.values()) { clearTimeout(timeout); } this.leaveTimeouts.clear(); } }   ","version":"Next","tagName":"h2"},{"title":"Voice Channel Tracking​","type":1,"pageTitle":"Voice State Management","url":"/docs/advanced/voice-state#voice-channel-tracking","content":" Track voice channel states across the bot:  class VoiceChannelTracker { private channelStates: Map&lt;string, { members: Set&lt;string&gt;; lastActivity: number; }&gt;; constructor(private yukino: YukinoClient) { this.channelStates = new Map(); this.setupEventListeners(); } private setupEventListeners() { // Track voice state changes this.yukino.connector.client.on('voiceStateUpdate', (oldState, newState) =&gt; { if (oldState.channelId) { this.removeUserFromChannel(oldState.channelId, oldState.member!.id); } if (newState.channelId) { this.addUserToChannel(newState.channelId, newState.member!.id); } }); // Track player creation this.yukino.node.on('playerCreate', (player) =&gt; { this.initializeChannelState(player.voiceChannelId); }); } private initializeChannelState(channelId: string) { const channel = this.yukino.connector.client.channels.cache.get( channelId ) as VoiceChannel; if (!channel) return; const members = new Set( channel.members .filter(member =&gt; !member.user.bot) .map(member =&gt; member.id) ); this.channelStates.set(channelId, { members, lastActivity: Date.now() }); } private addUserToChannel(channelId: string, userId: string) { const state = this.channelStates.get(channelId) || { members: new Set(), lastActivity: Date.now() }; state.members.add(userId); state.lastActivity = Date.now(); this.channelStates.set(channelId, state); } private removeUserFromChannel(channelId: string, userId: string) { const state = this.channelStates.get(channelId); if (!state) return; state.members.delete(userId); state.lastActivity = Date.now(); if (state.members.size === 0) { this.channelStates.delete(channelId); } } public getChannelMembers(channelId: string): string[] { return Array.from(this.channelStates.get(channelId)?.members || []); } public getChannelActivity(channelId: string): number { return this.channelStates.get(channelId)?.lastActivity || 0; } public isChannelEmpty(channelId: string): boolean { return this.getChannelMembers(channelId).length === 0; } }   ","version":"Next","tagName":"h2"},{"title":"Best Practices​","type":1,"pageTitle":"Voice State Management","url":"/docs/advanced/voice-state#best-practices","content":" Handle voice state errors:  player.on('error', (error) =&gt; { if (error.message.includes('voice')) { console.error('Voice connection error:', error); // Attempt to reconnect player.connect().catch(console.error); } });   Implement graceful disconnects:  async function disconnectGracefully(player: Player) { // Stop current track await player.stop(); // Clear queue player.queue.clear(); // Disconnect from voice await player.disconnect(); // Destroy player await player.destroy(); }   Monitor voice connection health:  class VoiceHealthMonitor { private healthChecks: Map&lt;string, { lastPing: number; failures: number; }&gt;; constructor(private yukino: YukinoClient) { this.healthChecks = new Map(); this.startMonitoring(); } private startMonitoring() { setInterval(() =&gt; { for (const [guildId, player] of this.yukino.players) { this.checkPlayerHealth(player); } }, 30000); // Check every 30 seconds } private async checkPlayerHealth(player: Player) { const health = this.healthChecks.get(player.guildId) || { lastPing: Date.now(), failures: 0 }; try { // Attempt to get voice state await player.node.rest.getPlayer( player.node.sessionId!, player.guildId ); health.lastPing = Date.now(); health.failures = 0; } catch (error) { health.failures++; if (health.failures &gt;= 3) { // Attempt to reconnect after 3 failures await player.connect().catch(console.error); health.failures = 0; } } this.healthChecks.set(player.guildId, health); } }  ","version":"Next","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/intro","content":"","keywords":"","version":"Next"},{"title":"What is Yukino?​","type":1,"pageTitle":"Introduction","url":"/docs/intro#what-is-yukino","content":" Yukino is a TypeScript library that connects your Discord.js bot to a Lavalink server, providing:  🎵 High-quality audio streaming🎚️ Advanced audio filters and effects📊 Queue management and track control🔄 Automatic voice state handling⚡ Excellent performance and stability🛡️ Full TypeScript support  ","version":"Next","tagName":"h2"},{"title":"Why Yukino?​","type":1,"pageTitle":"Introduction","url":"/docs/intro#why-yukino","content":" ","version":"Next","tagName":"h2"},{"title":"Easy to Use​","type":1,"pageTitle":"Introduction","url":"/docs/intro#easy-to-use","content":" import { YukinoClient } from 'yukino'; // Create a Yukino client const yukino = new YukinoClient(discordClient, { auth: 'your-password' }); // Play music const player = await yukino.createPlayer({ guildId: 'guild-id', voiceChannelId: 'channel-id' }); const result = await yukino.loadTrack('your favorite song'); await player.play({ track: result.data[0] });   ","version":"Next","tagName":"h3"},{"title":"Feature Rich​","type":1,"pageTitle":"Introduction","url":"/docs/intro#feature-rich","content":" Load tracks from various sources (YouTube, SoundCloud, etc.)Apply real-time audio filtersManage queues and playlistsHandle voice state changes automaticallyMonitor track and player events  ","version":"Next","tagName":"h3"},{"title":"Type Safe​","type":1,"pageTitle":"Introduction","url":"/docs/intro#type-safe","content":" // Get full TypeScript support interface PlayerOptions { guildId: string; voiceChannelId: string; textChannelId?: string; } const player = await yukino.createPlayer({ guildId, // Type checked! voiceChannelId // Type checked! });   ","version":"Next","tagName":"h3"},{"title":"Powerful Audio Control​","type":1,"pageTitle":"Introduction","url":"/docs/intro#powerful-audio-control","content":" // Apply audio filters await player.setFilters({ equalizer: [ { band: 0, gain: 0.3 }, { band: 1, gain: 0.2 } ], volume: 100, timescale: { speed: 1.2, pitch: 1.1 } }); // Control playback await player.pause(); await player.resume(); await player.seek(60000); // Seek to 1 minute   ","version":"Next","tagName":"h3"},{"title":"Queue Management​","type":1,"pageTitle":"Introduction","url":"/docs/intro#queue-management","content":" // Add tracks to queue player.queue.add(track); player.queue.addMany(tracks); // Control queue player.queue.shuffle(); player.queue.clear(); player.queue.remove(0); // Loop modes player.setLoop('track'); // Loop current track player.setLoop('queue'); // Loop entire queue player.setLoop('none'); // Disable looping   ","version":"Next","tagName":"h3"},{"title":"Key Concepts​","type":1,"pageTitle":"Introduction","url":"/docs/intro#key-concepts","content":" ","version":"Next","tagName":"h2"},{"title":"YukinoClient​","type":1,"pageTitle":"Introduction","url":"/docs/intro#yukinoclient","content":" The main client that manages the connection to Lavalink and creates players.  ","version":"Next","tagName":"h3"},{"title":"Node​","type":1,"pageTitle":"Introduction","url":"/docs/intro#node","content":" Represents a connection to a Lavalink server. Handles track loading and audio processing.  ","version":"Next","tagName":"h3"},{"title":"Player​","type":1,"pageTitle":"Introduction","url":"/docs/intro#player","content":" Manages playback for a specific voice channel. Controls audio output and track state.  ","version":"Next","tagName":"h3"},{"title":"Queue​","type":1,"pageTitle":"Introduction","url":"/docs/intro#queue","content":" Handles track organization and playback order for a player.  ","version":"Next","tagName":"h3"},{"title":"Getting Started​","type":1,"pageTitle":"Introduction","url":"/docs/intro#getting-started","content":" Ready to add music to your Discord bot? Follow our Installation Guide to get started!  ","version":"Next","tagName":"h2"},{"title":"Example Bot​","type":1,"pageTitle":"Introduction","url":"/docs/intro#example-bot","content":" Here's a complete example of a simple music bot using Yukino:  import { Client, GatewayIntentBits } from 'discord.js'; import { YukinoClient } from 'yukino'; const client = new Client({ intents: [ GatewayIntentBits.Guilds, GatewayIntentBits.GuildVoiceStates, GatewayIntentBits.GuildMessages ] }); const yukino = new YukinoClient(client, { auth: 'your-password', debug: true }); client.once('ready', () =&gt; { console.log('Bot is ready!'); yukino.connect(); }); client.on('interactionCreate', async (interaction) =&gt; { if (!interaction.isCommand()) return; switch (interaction.commandName) { case 'play': { const query = interaction.options.getString('song', true); const voiceChannel = interaction.member.voice.channel; if (!voiceChannel) { return interaction.reply('Join a voice channel first!'); } // Get or create player const player = yukino.getPlayer(interaction.guildId) || await yukino.createPlayer({ guildId: interaction.guildId, voiceChannelId: voiceChannel.id, textChannelId: interaction.channelId }); // Search and play const result = await yukino.loadTrack(query); if (result.data[0]) { player.queue.add(result.data[0]); if (!player.playing) { await player.play(); } await interaction.reply( `Added ${result.data[0].info.title} to the queue!` ); } break; } case 'stop': { const player = yukino.getPlayer(interaction.guildId); if (player) { await player.destroy(); await interaction.reply('Stopped playback!'); } break; } } }); client.login('your-token');   ","version":"Next","tagName":"h2"},{"title":"Next Steps​","type":1,"pageTitle":"Introduction","url":"/docs/intro#next-steps","content":" Follow the Installation Guide to set up YukinoCheck out the Quick Start Guide for basic usageExplore Core Concepts for in-depth understandingBrowse the API Reference for detailed documentation ","version":"Next","tagName":"h2"},{"title":"Installation Guide","type":0,"sectionRef":"#","url":"/docs/installation","content":"","keywords":"","version":"Next"},{"title":"Prerequisites​","type":1,"pageTitle":"Installation Guide","url":"/docs/installation#prerequisites","content":" Before installing Yukino, ensure you have:  Node.js version 16.x or higherJava version 17 or higher (for Lavalink)Discord Bot Token with these privileged intents: GUILDSGUILD_VOICE_STATESGUILD_MESSAGES  ","version":"Next","tagName":"h2"},{"title":"Installing Yukino​","type":1,"pageTitle":"Installation Guide","url":"/docs/installation#installing-yukino","content":" ","version":"Next","tagName":"h2"},{"title":"Using npm​","type":1,"pageTitle":"Installation Guide","url":"/docs/installation#using-npm","content":" npm install yukino discord.js   ","version":"Next","tagName":"h3"},{"title":"Using yarn​","type":1,"pageTitle":"Installation Guide","url":"/docs/installation#using-yarn","content":" yarn add yukino discord.js   ","version":"Next","tagName":"h3"},{"title":"Using pnpm​","type":1,"pageTitle":"Installation Guide","url":"/docs/installation#using-pnpm","content":" pnpm add yukino discord.js   ","version":"Next","tagName":"h3"},{"title":"Setting Up Lavalink​","type":1,"pageTitle":"Installation Guide","url":"/docs/installation#setting-up-lavalink","content":" ","version":"Next","tagName":"h2"},{"title":"1. Download Lavalink​","type":1,"pageTitle":"Installation Guide","url":"/docs/installation#1-download-lavalink","content":" Download the latest Lavalink.jar from:  Official Lavalink ReleasesOr use the direct link to the latest version: Lavalink.jar  ","version":"Next","tagName":"h3"},{"title":"2. Create Configuration​","type":1,"pageTitle":"Installation Guide","url":"/docs/installation#2-create-configuration","content":" Create application.yml in the same directory as Lavalink.jar:  server: port: 2333 address: 0.0.0.0 lavalink: server: password: &quot;youshallnotpass&quot; sources: youtube: true bandcamp: true soundcloud: true twitch: true vimeo: true http: true local: false bufferDurationMs: 400 frameBufferDurationMs: 1000 youtubePlaylistLoadLimit: 6 playerUpdateInterval: 5 youtubeSearchEnabled: true soundcloudSearchEnabled: true gc-warnings: true metrics: prometheus: enabled: false endpoint: /metrics sentry: dsn: &quot;&quot; environment: &quot;&quot; logging: file: max-history: 30 max-size: 1GB path: ./logs/ level: root: INFO lavalink: INFO   ","version":"Next","tagName":"h3"},{"title":"3. Start Lavalink​","type":1,"pageTitle":"Installation Guide","url":"/docs/installation#3-start-lavalink","content":" Create a startup script:  Windows (start.bat)​  java -jar Lavalink.jar   Linux/macOS (start.sh)​  #!/bin/bash java -jar Lavalink.jar   Make the script executable on Linux/macOS:  chmod +x start.sh   ","version":"Next","tagName":"h3"},{"title":"4. Configure Your Bot​","type":1,"pageTitle":"Installation Guide","url":"/docs/installation#4-configure-your-bot","content":" Basic setup with TypeScript:  import { Client, GatewayIntentBits } from 'discord.js'; import { YukinoClient } from 'yukino'; // Create Discord.js client const client = new Client({ intents: [ GatewayIntentBits.Guilds, GatewayIntentBits.GuildVoiceStates, GatewayIntentBits.GuildMessages, GatewayIntentBits.MessageContent ] }); // Create Yukino client const yukino = new YukinoClient(client, { client: client, auth: 'youshallnotpass', // Must match Lavalink password debug: true // Enable for detailed logging }, { name: 'default', url: 'localhost:2333', auth: 'youshallnotpass', secure: false, // Use true for HTTPS version: '4' // Lavalink API version }); // Connect when bot is ready client.once('ready', () =&gt; { console.log('Bot is ready!'); yukino.connect(); }); // Login to Discord client.login('YOUR_BOT_TOKEN');   ","version":"Next","tagName":"h3"},{"title":"Development Setup​","type":1,"pageTitle":"Installation Guide","url":"/docs/installation#development-setup","content":" ","version":"Next","tagName":"h2"},{"title":"1. Project Structure​","type":1,"pageTitle":"Installation Guide","url":"/docs/installation#1-project-structure","content":" Recommended project structure:  your-bot/ ├── src/ │ ├── index.ts │ ├── commands/ │ │ └── music/ │ ├── events/ │ │ └── voice/ │ └── utils/ ├── lavalink/ │ ├── Lavalink.jar │ └── application.yml ├── package.json └── tsconfig.json   ","version":"Next","tagName":"h3"},{"title":"2. TypeScript Configuration​","type":1,"pageTitle":"Installation Guide","url":"/docs/installation#2-typescript-configuration","content":" Create tsconfig.json:  { &quot;compilerOptions&quot;: { &quot;target&quot;: &quot;ES2020&quot;, &quot;module&quot;: &quot;commonjs&quot;, &quot;strict&quot;: true, &quot;esModuleInterop&quot;: true, &quot;skipLibCheck&quot;: true, &quot;forceConsistentCasingInFileNames&quot;: true, &quot;outDir&quot;: &quot;dist&quot;, &quot;rootDir&quot;: &quot;src&quot; }, &quot;include&quot;: [&quot;src&quot;], &quot;exclude&quot;: [&quot;node_modules&quot;] }   ","version":"Next","tagName":"h3"},{"title":"3. Package Configuration​","type":1,"pageTitle":"Installation Guide","url":"/docs/installation#3-package-configuration","content":" Update your package.json:  { &quot;name&quot;: &quot;your-bot&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;scripts&quot;: { &quot;start&quot;: &quot;node dist/index.js&quot;, &quot;dev&quot;: &quot;ts-node src/index.ts&quot;, &quot;build&quot;: &quot;tsc&quot;, &quot;lavalink&quot;: &quot;cd lavalink &amp;&amp; java -jar Lavalink.jar&quot; }, &quot;dependencies&quot;: { &quot;discord.js&quot;: &quot;^14.0.0&quot;, &quot;yukino&quot;: &quot;^1.0.0&quot; }, &quot;devDependencies&quot;: { &quot;typescript&quot;: &quot;^4.9.0&quot;, &quot;ts-node&quot;: &quot;^10.9.0&quot;, &quot;@types/node&quot;: &quot;^18.0.0&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Production Setup​","type":1,"pageTitle":"Installation Guide","url":"/docs/installation#production-setup","content":" ","version":"Next","tagName":"h2"},{"title":"1. Docker Setup​","type":1,"pageTitle":"Installation Guide","url":"/docs/installation#1-docker-setup","content":" Create a Dockerfile:  FROM node:16-alpine WORKDIR /app COPY package*.json ./ RUN npm install COPY . . RUN npm run build CMD [&quot;npm&quot;, &quot;start&quot;]   Create a docker-compose.yml:  version: '3.8' services: lavalink: image: fredboat/lavalink:latest container_name: lavalink restart: unless-stopped environment: - SERVER_PORT=2333 - SERVER_ADDRESS=0.0.0.0 - LAVALINK_SERVER_PASSWORD=youshallnotpass volumes: - ./lavalink/application.yml:/opt/Lavalink/application.yml networks: - bot-network bot: build: . container_name: music-bot restart: unless-stopped depends_on: - lavalink environment: - DISCORD_TOKEN=your-bot-token - LAVALINK_HOST=lavalink - LAVALINK_PORT=2333 - LAVALINK_PASSWORD=youshallnotpass networks: - bot-network networks: bot-network: driver: bridge   ","version":"Next","tagName":"h3"},{"title":"2. Process Management​","type":1,"pageTitle":"Installation Guide","url":"/docs/installation#2-process-management","content":" For non-Docker deployments, use PM2:  # Install PM2 npm install -g pm2 # Start Lavalink pm2 start &quot;java -jar Lavalink.jar&quot; --name &quot;lavalink&quot; --cwd &quot;./lavalink&quot; # Start bot pm2 start npm --name &quot;music-bot&quot; -- start # Save PM2 configuration pm2 save # Enable startup on system boot pm2 startup   ","version":"Next","tagName":"h3"},{"title":"Troubleshooting​","type":1,"pageTitle":"Installation Guide","url":"/docs/installation#troubleshooting","content":" ","version":"Next","tagName":"h2"},{"title":"Common Issues​","type":1,"pageTitle":"Installation Guide","url":"/docs/installation#common-issues","content":" Lavalink Connection Failed Check if Java 17+ is installedVerify Lavalink is running (default port: 2333)Confirm passwords match in both Lavalink and bot configs Voice Connection Issues Verify bot has required intentsCheck voice channel permissionsEnable debug logging for detailed error messages Track Loading Failed Check Lavalink server logsVerify source is enabled in application.ymlTest with direct YouTube URL first  ","version":"Next","tagName":"h3"},{"title":"Debug Mode​","type":1,"pageTitle":"Installation Guide","url":"/docs/installation#debug-mode","content":" Enable debug mode for detailed logging:  const yukino = new YukinoClient(client, { // ...other options debug: true });   ","version":"Next","tagName":"h3"},{"title":"Health Check​","type":1,"pageTitle":"Installation Guide","url":"/docs/installation#health-check","content":" Create a simple health check endpoint:  import express from 'express'; const app = express(); app.get('/health', (req, res) =&gt; { const status = { bot: client.isReady(), lavalink: yukino.isReady, players: yukino.players.size }; res.json(status); }); app.listen(3000);  ","version":"Next","tagName":"h3"},{"title":"Error Handling","type":0,"sectionRef":"#","url":"/docs/advanced/error-handling","content":"","keywords":"","version":"Next"},{"title":"Common Error Types​","type":1,"pageTitle":"Error Handling","url":"/docs/advanced/error-handling#common-error-types","content":" ","version":"Next","tagName":"h2"},{"title":"Node Errors​","type":1,"pageTitle":"Error Handling","url":"/docs/advanced/error-handling#node-errors","content":" yukino.node.on('nodeError', (node, error) =&gt; { console.error(`Node ${node.name} encountered an error:`, error); // Implement recovery logic }); yukino.node.on('nodeClosed', (node, code, reason) =&gt; { console.error(`Node ${node.name} closed with code ${code}:`, reason); // Handle unexpected disconnects });   ","version":"Next","tagName":"h3"},{"title":"Track Errors​","type":1,"pageTitle":"Error Handling","url":"/docs/advanced/error-handling#track-errors","content":" yukino.node.on('trackError', (player, track, error) =&gt; { console.error('Track playback failed:', { track: track.info.title, error: error.message }); // Skip to next track player.skip().catch(console.error); }); yukino.node.on('trackStuck', (player, track, thresholdMs) =&gt; { console.warn('Track got stuck:', { track: track.info.title, threshold: thresholdMs }); // Skip or retry playback player.seek(player.position + 1000).catch(() =&gt; player.skip()); });   ","version":"Next","tagName":"h3"},{"title":"Error Recovery System​","type":1,"pageTitle":"Error Handling","url":"/docs/advanced/error-handling#error-recovery-system","content":" Implement a robust error recovery system:  class ErrorRecoverySystem { private recoveryAttempts: Map&lt;string, { count: number; lastError: Date; }&gt;; constructor(private yukino: YukinoClient) { this.recoveryAttempts = new Map(); this.setupErrorHandlers(); } private setupErrorHandlers() { // Node errors this.yukino.node.on('nodeError', this.handleNodeError.bind(this)); this.yukino.node.on('nodeClosed', this.handleNodeClosed.bind(this)); // Track errors this.yukino.node.on('trackError', this.handleTrackError.bind(this)); this.yukino.node.on('trackStuck', this.handleTrackStuck.bind(this)); // Voice errors this.yukino.node.on('voiceStateUpdate', this.handleVoiceError.bind(this)); } private async handleNodeError(node: Node, error: Error) { const attempts = this.getRecoveryAttempts(node.name); if (attempts.count &lt; 3) { // Try to reconnect try { await node.connect(); this.resetRecoveryAttempts(node.name); } catch (e) { attempts.count++; attempts.lastError = new Date(); this.recoveryAttempts.set(node.name, attempts); } } else { // Switch to fallback node if available this.handleNodeFailover(node); } } private async handleNodeClosed(node: Node, code: number, reason: string) { if (code === 1000) { // Normal closure, no recovery needed return; } // Attempt reconnection with exponential backoff const attempts = this.getRecoveryAttempts(node.name); const backoff = Math.min(1000 * Math.pow(2, attempts.count), 30000); setTimeout(async () =&gt; { try { await node.connect(); this.resetRecoveryAttempts(node.name); } catch (e) { attempts.count++; attempts.lastError = new Date(); this.recoveryAttempts.set(node.name, attempts); if (attempts.count &lt; 5) { this.handleNodeClosed(node, code, reason); } } }, backoff); } private async handleTrackError(player: Player, track: Track, error: Error) { const attempts = this.getRecoveryAttempts(`track:${track.encoded}`); if (attempts.count &lt; 2) { // Try to restart the track try { await player.play({ track, options: { startTime: player.position } }); this.resetRecoveryAttempts(`track:${track.encoded}`); } catch (e) { attempts.count++; attempts.lastError = new Date(); this.recoveryAttempts.set(`track:${track.encoded}`, attempts); // Skip to next track if restart fails await player.skip().catch(console.error); } } else { // Skip to next track after multiple failures await player.skip().catch(console.error); } } private async handleTrackStuck(player: Player, track: Track, thresholdMs: number) { // Try to seek past the stuck point try { await player.seek(player.position + thresholdMs); } catch (e) { // Skip if seeking fails await player.skip().catch(console.error); } } private async handleVoiceError(state: any) { const player = this.yukino.getPlayer(state.guild_id); if (!player) return; const attempts = this.getRecoveryAttempts(`voice:${state.guild_id}`); if (attempts.count &lt; 3) { try { await player.connect(); this.resetRecoveryAttempts(`voice:${state.guild_id}`); } catch (e) { attempts.count++; attempts.lastError = new Date(); this.recoveryAttempts.set(`voice:${state.guild_id}`, attempts); } } } private async handleNodeFailover(node: Node) { // Find alternate node const alternateNode = Array.from(this.yukino.connector.nodes.values()) .find(n =&gt; n !== node &amp;&amp; n.state === State.CONNECTED); if (!alternateNode) { console.error('No alternate nodes available'); return; } // Move players to alternate node for (const [guildId, player] of this.yukino.players) { if (player.node === node) { try { const track = player.current; const position = player.position; // Create new player on alternate node const newPlayer = await this.yukino.createPlayer({ guildId: player.guildId, voiceChannelId: player.voiceChannelId, textChannelId: player.textChannelId }); // Restore playback state if (track) { await newPlayer.play({ track, options: { startTime: position } }); } // Copy queue player.queue.tracks.forEach(t =&gt; newPlayer.queue.add(t)); } catch (e) { console.error(`Failed to migrate player for guild ${guildId}:`, e); } } } } private getRecoveryAttempts(id: string) { return ( this.recoveryAttempts.get(id) || { count: 0, lastError: new Date() } ); } private resetRecoveryAttempts(id: string) { this.recoveryAttempts.set(id, { count: 0, lastError: new Date() }); } // Cleanup public destroy() { this.recoveryAttempts.clear(); } }   ","version":"Next","tagName":"h2"},{"title":"Error Logging​","type":1,"pageTitle":"Error Handling","url":"/docs/advanced/error-handling#error-logging","content":" Implement comprehensive error logging:  class ErrorLogger { constructor( private yukino: YukinoClient, private options: { logToFile?: boolean; logToConsole?: boolean; logDirectory?: string; } = {} ) { this.setupLoggers(); } private setupLoggers() { // Node errors this.yukino.node.on('nodeError', (node, error) =&gt; { this.logError('NODE_ERROR', { node: node.name, error: error.message, stack: error.stack }); }); // Track errors this.yukino.node.on('trackError', (player, track, error) =&gt; { this.logError('TRACK_ERROR', { guild: player.guildId, track: track.info.title, error: error.message }); }); // Voice errors this.yukino.node.on('voiceStateUpdate', (state) =&gt; { if (state.error) { this.logError('VOICE_ERROR', { guild: state.guild_id, error: state.error }); } }); } private logError(type: string, data: any) { const timestamp = new Date().toISOString(); const logEntry = { timestamp, type, ...data }; if (this.options.logToConsole) { console.error(`[${timestamp}] ${type}:`, data); } if (this.options.logToFile) { // Implement file logging const path = require('path'); const fs = require('fs'); const logPath = path.join( this.options.logDirectory || 'logs', `yukino-${new Date().toISOString().split('T')[0]}.log` ); fs.appendFileSync( logPath, JSON.stringify(logEntry) + '\\n' ); } } }   ","version":"Next","tagName":"h2"},{"title":"Best Practices​","type":1,"pageTitle":"Error Handling","url":"/docs/advanced/error-handling#best-practices","content":" Implement circuit breakers:  class CircuitBreaker { private failures = 0; private lastFailure: Date | null = null; private state: 'closed' | 'open' | 'half-open' = 'closed'; constructor( private threshold: number = 5, private timeout: number = 60000 ) {} async execute&lt;T&gt;(operation: () =&gt; Promise&lt;T&gt;): Promise&lt;T&gt; { if (this.state === 'open') { if (this.shouldReset()) { this.state = 'half-open'; } else { throw new Error('Circuit breaker is open'); } } try { const result = await operation(); if (this.state === 'half-open') { this.reset(); } return result; } catch (error) { this.recordFailure(); throw error; } } private recordFailure() { this.failures++; this.lastFailure = new Date(); if (this.failures &gt;= this.threshold) { this.state = 'open'; } } private shouldReset(): boolean { return ( this.lastFailure &amp;&amp; Date.now() - this.lastFailure.getTime() &gt;= this.timeout ); } private reset() { this.failures = 0; this.lastFailure = null; this.state = 'closed'; } }   Implement retry with exponential backoff:  async function withRetry&lt;T&gt;( operation: () =&gt; Promise&lt;T&gt;, maxAttempts = 3, baseDelay = 1000 ): Promise&lt;T&gt; { for (let attempt = 1; attempt &lt;= maxAttempts; attempt++) { try { return await operation(); } catch (error) { if (attempt === maxAttempts) throw error; const delay = baseDelay * Math.pow(2, attempt - 1); await new Promise(r =&gt; setTimeout(r, delay)); } } throw new Error('Should not reach here'); }   Handle cleanup properly:  process.on('SIGINT', async () =&gt; { // Gracefully stop all players for (const [_, player] of yukino.players) { try { await player.stop(); await player.disconnect(); await player.destroy(); } catch (error) { console.error('Cleanup error:', error); } } // Disconnect from nodes for (const [_, node] of yukino.connector.nodes) { try { await node.destroy(); } catch (error) { console.error('Node cleanup error:', error); } } process.exit(0); });  ","version":"Next","tagName":"h2"},{"title":"Quick Start Guide","type":0,"sectionRef":"#","url":"/docs/quickstart","content":"","keywords":"","version":"Next"},{"title":"Prerequisites​","type":1,"pageTitle":"Quick Start Guide","url":"/docs/quickstart#prerequisites","content":" Make sure you have:  Installed Yukino and Discord.js (npm install yukino discord.js)Set up Lavalink (see Installation Guide)Created a Discord bot with required intents  ","version":"Next","tagName":"h2"},{"title":"Basic Setup​","type":1,"pageTitle":"Quick Start Guide","url":"/docs/quickstart#basic-setup","content":" Create a new file bot.js or bot.ts:  import { Client, GatewayIntentBits } from 'discord.js'; import { YukinoClient } from 'yukino'; // Create Discord.js client const client = new Client({ intents: [ GatewayIntentBits.Guilds, GatewayIntentBits.GuildVoiceStates, GatewayIntentBits.GuildMessages, GatewayIntentBits.MessageContent ] }); // Create Yukino client const yukino = new YukinoClient(client, { auth: 'youshallnotpass', // Your Lavalink password debug: true }); // Connect when ready client.once('ready', () =&gt; { console.log('Bot is ready!'); yukino.connect(); }); // Login client.login('YOUR_BOT_TOKEN');   ","version":"Next","tagName":"h2"},{"title":"Basic Commands​","type":1,"pageTitle":"Quick Start Guide","url":"/docs/quickstart#basic-commands","content":" Add these command handlers to your bot:  client.on('interactionCreate', async (interaction) =&gt; { if (!interaction.isCommand()) return; const { commandName } = interaction; // Play Command if (commandName === 'play') { const query = interaction.options.getString('song', true); const voiceChannel = interaction.member.voice.channel; if (!voiceChannel) { return interaction.reply('You need to be in a voice channel!'); } try { // Get or create player let player = yukino.getPlayer(interaction.guildId); if (!player) { player = await yukino.createPlayer({ guildId: interaction.guildId, voiceChannelId: voiceChannel.id, textChannelId: interaction.channelId }); } // Search for track const result = await yukino.loadTrack(query); if (result.data.length === 0) { return interaction.reply('No results found!'); } // Add to queue and play const track = result.data[0]; player.queue.add(track); if (!player.playing) { await player.play(); } await interaction.reply( `Added **${track.info.title}** to the queue!` ); } catch (error) { console.error('Play command error:', error); await interaction.reply('An error occurred!'); } } // Pause Command if (commandName === 'pause') { const player = yukino.getPlayer(interaction.guildId); if (!player) { return interaction.reply('Nothing is playing!'); } await player.pause(!player.paused); await interaction.reply( player.paused ? 'Paused!' : 'Resumed!' ); } // Skip Command if (commandName === 'skip') { const player = yukino.getPlayer(interaction.guildId); if (!player) { return interaction.reply('Nothing is playing!'); } await player.skip(); await interaction.reply('Skipped!'); } // Stop Command if (commandName === 'stop') { const player = yukino.getPlayer(interaction.guildId); if (!player) { return interaction.reply('Nothing is playing!'); } await player.destroy(); await interaction.reply('Stopped playback!'); } // Queue Command if (commandName === 'queue') { const player = yukino.getPlayer(interaction.guildId); if (!player) { return interaction.reply('Queue is empty!'); } const current = player.current; const queue = player.queue.tracks; let response = '**Now Playing:**\\n'; response += current ? `${current.info.title}\\n\\n` : 'Nothing\\n\\n'; if (queue.length &gt; 0) { response += '**Queue:**\\n'; response += queue .slice(0, 10) .map((track, i) =&gt; `${i + 1}. ${track.info.title}`) .join('\\n'); if (queue.length &gt; 10) { response += `\\n...and ${queue.length - 10} more`; } } await interaction.reply(response); } });   ","version":"Next","tagName":"h2"},{"title":"Register Slash Commands​","type":1,"pageTitle":"Quick Start Guide","url":"/docs/quickstart#register-slash-commands","content":" Create and register your slash commands:  import { REST, Routes, SlashCommandBuilder } from 'discord.js'; const commands = [ new SlashCommandBuilder() .setName('play') .setDescription('Play a song') .addStringOption(option =&gt; option .setName('song') .setDescription('Song name or URL') .setRequired(true) ), new SlashCommandBuilder() .setName('pause') .setDescription('Pause/resume playback'), new SlashCommandBuilder() .setName('skip') .setDescription('Skip current song'), new SlashCommandBuilder() .setName('stop') .setDescription('Stop playback'), new SlashCommandBuilder() .setName('queue') .setDescription('Show current queue') ]; const rest = new REST({ version: '10' }).setToken('YOUR_BOT_TOKEN'); (async () =&gt; { try { await rest.put( Routes.applicationCommands('YOUR_CLIENT_ID'), { body: commands } ); console.log('Commands registered!'); } catch (error) { console.error('Failed to register commands:', error); } })();   ","version":"Next","tagName":"h2"},{"title":"Basic Event Handling​","type":1,"pageTitle":"Quick Start Guide","url":"/docs/quickstart#basic-event-handling","content":" Add basic event handlers for track events:  yukino.node.on('trackStart', (player, track) =&gt; { const channel = client.channels.cache.get(player.textChannelId); if (channel?.isTextBased()) { channel.send(`Now playing: **${track.info.title}**`); } }); yukino.node.on('trackEnd', (player, track) =&gt; { if (player.queue.length === 0) { const channel = client.channels.cache.get(player.textChannelId); if (channel?.isTextBased()) { channel.send('Queue ended!'); } } }); yukino.node.on('trackError', (player, track, error) =&gt; { console.error('Track error:', error); const channel = client.channels.cache.get(player.textChannelId); if (channel?.isTextBased()) { channel.send(`Error playing **${track.info.title}**!`); } });   ","version":"Next","tagName":"h2"},{"title":"Run the Bot​","type":1,"pageTitle":"Quick Start Guide","url":"/docs/quickstart#run-the-bot","content":" Start Lavalink:  java -jar Lavalink.jar   Start your bot:  node bot.js # or with TypeScript ts-node bot.ts   ","version":"Next","tagName":"h2"},{"title":"Next Steps​","type":1,"pageTitle":"Quick Start Guide","url":"/docs/quickstart#next-steps","content":" Now that you have a basic music bot running, you can:  Add more commands (volume, seek, filters, etc.)Implement queue management featuresAdd error handlingExplore advanced features  Check out these guides for more:  Core Concepts for detailed API understandingFeatures for advanced functionalityAdvanced Topics for complex use cases ","version":"Next","tagName":"h2"}],"options":{"id":"default"}}